<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fishjump&#39;s blog</title>
  
  <subtitle>fly,fly,fly</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-20T17:30:10.539Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fishjump</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP-第七章—链接</title>
    <link href="http://example.com/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/"/>
    <id>http://example.com/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/</id>
    <published>2024-03-20T17:28:04.000Z</published>
    <updated>2024-03-20T17:30:10.539Z</updated>
    
    <content type="html"><![CDATA[<p>虽然现在还没怎么使用过链接，因为小项目往往单个文件即可完美解决，但是当工程量大的时候，多文件操作是不可避免的。链接就是将各种代码和数据片段收集并组合成一个单一文件的过程。</p><span id="more"></span><h4 id="为什么学习链接："><a href="#为什么学习链接：" class="headerlink" title="为什么学习链接："></a>为什么学习链接：</h4><ul><li>理解链接有利于我们构造大型程序。</li><li>理解链接器将帮助我们避免一些危险的编程错误。</li><li>理解链接帮助我们理解语言的作用域规则是如何实现的。</li><li>理解链接将帮助我们理解其他重要的系统概念。</li><li>理解链接使我们能够利用共享库。</li></ul><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><blockquote><p>静态链接（Static linking）是指在编译阶段将目标文件中所需的库文件代码全部复制到可执行文件中，形成一个独立的、完整的可执行文件。在运行程序时，操作系统不需要加载额外的库文件，因为所有必要的代码都已经包含在可执行文件中。</p></blockquote><p>优点：执行速度快、稳定性好、容易分发（移植性高？）、安全性高</p><p>缺点：可执行文件大、更新困难、内存浪费</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><blockquote><p>动态链接（Dynamic linking）是指在程序运行时，需要某个库文件时才去查找和载入所需的库文件。与静态链接不同，动态链接并不会将所有的代码和数据都打包到可执行文件中，而是在程序启动时只加载所需的代码和数据，避免了一些资源浪费的问题。</p></blockquote><p>优点：文件小、容易更新、节约内存、更容易定位问题</p><p>缺点：执行速度较慢、安全性问题、容易出错</p><h3 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h3><p>跟着书上操作一下</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603152948.png"></p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603153012.png"></p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603153106.png"></p><p>了解一下gcc的使用：<strong>gcc -Og -o prog main.c sum.c</strong></p><ul><li><code>gcc</code>: 使用 GNU C 编译器</li><li><code>-Og</code>: 优化级别为“优化等级 g”，即启用大多数优化选项，但不会影响调试信息。</li><li><code>-o prog</code>: 将生成的可执行文件命名为 <code>prog</code>。（如果没有该选项，则默认生成名为 <code>a.out</code> 的可执行文件）</li><li><code>main.c</code>: 主程序文件，包含程序的入口函数。</li><li><code>sum.c</code>: 函数库文件，包含用于计算求和的函数代码。</li></ul><p>综上所述，该命令会将 <code>main.c</code> 和 <code>sum.c</code> 两个源文件编译成一个名为 <code>prog</code> 的可执行文件，并且在编译过程中启用了大多数优化选项，同时保留了调试信息以方便调试。</p><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>目标文件有三种形式</p><ul><li>可重定位目标文件。包含二进制代码和数据，可执行目标文件的中间产物。</li></ul><blockquote><p>可重定位目标文件包含了代码、数据和符号表等信息，但并不包含所有的地址信息。因此，在链接时需要通过重新定位（relocation）来分配地址，并建立各个目标文件之间的联系，生成最终的可执行文件或动态链接库。</p></blockquote><ul><li>可执行目标文件。包含二进制代码和数据，可以直接复制到内存并执行。</li><li>共享目标文件。一种特殊类型的可重定位文件。</li></ul><h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603162030.png"></p><p>我们拿一个具体的文件对照着理解</p><p>mian1.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> count=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> sum)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum is:%d\n&quot;</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">        func(a+b+x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gcc -c main1.c</strong>  命令将源文件编译成可重定位目标文件。-c只编译源代码不进行链接操作，生成main1.o文件</p><p> <strong>readelf -h main1.o</strong>   -h选项表示只显示header信息。</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603163426.png"></p><p>这就是7-3所示的ELF头的内容。</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603163658.png"></p><p>我们可以看到节头部表的起始位置是992.共有14个表，每个长度为64字节。992+14*64&#x3D;1888和我们用wc（word count）命令查看的文件的字节数目一致。</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603164202.png"></p><p><strong>readelf -S main1.o</strong>  -S选项，打印整个表的信息</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603164339.png"></p><p><strong>.text</strong>：存放已经编译好的机器代码。通过objdump -s -d main1.o命令可以查看<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603165048.png"></p><p><strong>.data</strong>：存放已经初始化的全局和静态变量<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603165408.png"></p><p>我们初始化了一个count和a，值分别为10和1.其实还初始化了b，不过赋值为0，当作未初始化处理。我们看到的是小端存储，0a000000实际上是0000000a。</p><p><strong>.bss</strong>：未初始化的全局变量和静态变量，以及所以被初始化为0的全局或静态变量。在目标文件中这个节不占实际的空间，仅仅是一个占位符。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603170707.png"></p><p>可以看到他和.rodata起始位置是相同的。</p><blockquote><p><code>.bss</code> 段不包含实际的数据内容，是因为该段中存储的是未初始化的全局变量和静态变量。在程序启动时，这些变量会被自动初始化为 0 或者 NULL，而不是在编译时就确定了其具体的值。因此，在编译时并没有将这些变量的实际值保存到 <code>.bss</code> 段中。</p><p>对于已经初始化的全局变量和静态变量，它们将被保存在 <code>.data</code> 段或 <code>.rodata</code> 段中，并在编译时就确定了其具体的值。相比之下，<code>.bss</code> 段只是记录了需要分配多少空间给未初始化的变量，并在程序启动时进行自动初始化。因此，<code>.bss</code> 段中不包含实际的数据内容。</p></blockquote><p>.rodata：只读文件，比如printf语句中的格式串和开关语句的跳转表<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603171213.png"></p><p>其余的</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603171455.png"></p><h3 id="符号和符号表"><a href="#符号和符号表" class="headerlink" title="符号和符号表"></a>符号和符号表</h3><p>每个可重定位目标模块m都有一个符号表，它包含m定义和应用的符号的信息。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603174013.png"></p><p><strong>readelf -s main1.o</strong>  查看符号表内容<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603171927.png"></p><p>从这个表中我们可以看到所有定义的符号以及他们的位置和大小。比如说main函数，在0x2b处大小是52字节。对于count 和 value 他俩的type为object表明符号是个数据对象，ndx值是其段位置，3代表count在section3即.data中。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603173509.png"></p><p>局部变量x并未出现在符号表中，因为局部变量在运行时栈中被管理，因此不会出现。</p><h3 id="符号解析与静态库"><a href="#符号解析与静态库" class="headerlink" title="符号解析与静态库"></a>符号解析与静态库</h3><p>链接器解析符号引用的方法是将每个引用与他输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对于局部变量，解析是非常明了的。对于全局变量，编译器会假设他在其他的某个模块被定义，如果链接器在任何一个模块中都未被定义，就会输出一个错误信息并终止。   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        foo();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603180037.png"></p><p>编译和汇编过程没有问题。连接成可执行文件时报错<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603180303.png"></p><h4 id="编译器如何解析多重定义的全局符号"><a href="#编译器如何解析多重定义的全局符号" class="headerlink" title="编译器如何解析多重定义的全局符号"></a>编译器如何解析多重定义的全局符号</h4><p>全局符号分强弱两种类型。</p><p>强符号：函数和已经初始化的全局变量</p><p>弱符号：未初始化的全局变量<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603180723.png"></p><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>静态库就是各种可重定位文件的集合，如lib.a静态库就包含了printf.o等</p><p>静态链接就是链接静态库的过程。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603181855.png"></p><h3 id="静态库的解析过程"><a href="#静态库的解析过程" class="headerlink" title="静态库的解析过程"></a>静态库的解析过程</h3><p>连接器从左到右扫描文件并维护三个集合，顺序是比较重要的</p><p>E：可重定位目标文件的集合，这个集合会被合并起来并形成可执行文件。</p><p>U：未解析的符号（引用了但是尚未定义的符号）集合</p><p>D：在前面输入文件中已经定义的符号集合。</p><p>最开始是空的</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603183005.png"></p><p>接收目标文件放入E<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603183029.png"></p><p>main中有未解析的符号<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603183038.png"></p><p>继续往下查看静态库，发现了addvec的定义，于是从U中删除，将addvec.o放入E中<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230603183118.png"></p><p>D的目的是动心定位，分配地址。</p><h3 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h3><p>重定位合并输入模块，并未每个模块分配运行时地址。重定位由两步组成：</p><ul><li><strong>重定位节和符号定义</strong>  。将相同类型的节合并，然后链接器将运行时内存地址赋给新的聚合节。当这一步完成时，程序的每个指令和全局变量都有唯一的运行时内存地址了。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604022044.png"></li><li><strong>重定位节中的符号引用</strong> 。连接器修改代码节和数据节中对每个符号的引用，使得他们指向正确的。</li></ul><h4 id="重定位条目"><a href="#重定位条目" class="headerlink" title="重定位条目"></a>重定位条目</h4><p>当汇编器生成一个目标模块时，并不知道数据和代码最终将存放在什么位置。当汇编器遇到对最终位置未知的目标引用，他就会生成一个可重定位条条目，告诉连接器在将文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604023138.png"></p><p>在重定位之前，操作码之后的内容被汇编器填充为0<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604023934.png"></p><p>根据重定位条目来确定具体内容。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604024716.png"></p><p>0x5,是两个地址之间的距离<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604024928.png"></p><p>现在学的内容和当时学习汇编语言接触到的东西接轨了，比如说为什么call指令会进行这样那样的操作，jmp指令有的是相对跳转有的是绝对跳转。这里解释的是重定位相对引用。</p><p>重定位绝对引用比较简单<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604025205.png"></p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604025246.png"></p><p>最终<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604025318.png"></p><h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p>可以复制到内存并直接执行的文件<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604144059.png"></p><p>ELF头描述文件的总体格式，它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604154958.png"></p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604155129.png"></p><p><strong>.&#x2F;prog</strong> 运行可执行文件prog。</p><h3 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h3><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230604162238.png"></p><h3 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h3><blockquote><p>库打桩机制允许你接获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数。验证和追踪它的输入值和输出值，或者甚至把他天换成一个完全不同的实现。</p></blockquote><p>先说明一下库打桩的应用场景，比如说我们使用库函数malloc()，他返回一个地址，而我们呢想知道malloc函数被调用了多少次，这时我们就可以通过库打桩将我们自己编写的可以打印信息的mymolloc进行替换，这好像和hook有点关系。库打桩技术的主要思想是:在不修改原程序源代码的情况下,替换掉不稳定或难以获取的第三方库。替换的库称为桩库或模拟库,它实现目标库的接口,但是里面的实现是自定义的代码。通过使用桩库,可以<strong>隔离原程序与第三方库</strong>,便于测试或解决依赖问题。常用于软件测试中,以提高测试用例的准确性和可重复性。</p><p>按照打桩时机，库打桩分为以下三类：</p><ol><li>编译时打桩。此种情况需要能够访问源代码。</li><li>链接时打桩。需要能够访问可重定位文件文件。</li><li>运行时打桩。没有上述需求，比较nb。</li></ol><h4 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h4><p>使用宏定义将malloc()定义为mymalloc()即可，自定义malloc.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) mymalloc(size)</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>接下来我们自定义malloc的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXX      <span class="comment">//相当于一个if语句，就是如果定义了宏XXX，下面的代码就会被加载，在编译中我们使用DXXX来定义XXX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//打桩函数</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mymalloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr=<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mzy success\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;malloc.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -DMYMOCK -c mymalloc.c    <span class="comment">#编译源代码文件而不进行链接</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -I . -o main main.c mymalloc.o</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230605021520.png"></p><p>很离谱的是没有任何反应<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230605021707.png"></p><p>经过一番求助之后，原来是tmd头文件的名字写错了，<img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230605110200.png"></p><p>跟着这个就来了，但是作者是怎么成功的呢，按理来说他应该include”mymalooc.h”才对呀。</p><h4 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h4><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230605110428.png"></p><p>l连接过程中对应关系是</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span>       ----&gt;     _ _wrap_fun</span></span><br><span class="line">__real_f  ----&gt;     <span class="function"><span class="keyword">fun</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *__real_malloc(<span class="type">size_t</span> size);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* __wrap_malloc(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr =__real_malloc(size);<span class="comment">//调用malooc</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mzy success*2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.c和上面有一点不同，将头文件去掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include&quot;malloc.h&quot;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p =<span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -DXXX -c mymalloc.c    <span class="comment">#得到mymalloc.o</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -c main.c               <span class="comment">#得到main.o</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -Wl,--wrap,malloc -o main main.o mymalloc.o</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#-Wl,--wrap,malloc把--wrap malloc传递给链接器</span></span></span><br></pre></td></tr></table></figure><h4 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h4><p>不需要源代码，不需要重定位文件，太酷啦。在学习这个炫酷的技能之前，我们先了解一下如何制造动态库。</p><h5 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h5><p>test.c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>制作生成.so文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc test.c -fPIC -shared -o libtest.so</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -DMYMOCK -shared -fPIC -o libmymalloc.so mymalloc.c -ldl</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>-DMYMOCK</code>：定义预处理器宏 <code>MYMOCK</code>，使得在编译时预处理阶段可以根据这个宏名称进行条件编译。</li><li><code>-shared</code>：指定生成一个共享库（即动态链接库）。</li><li><code>-fPIC</code>：指定编译为位置独立代码（Position Independent Code），以便被动态链接库调用。</li><li><code>-o libmymalloc.so</code>：指定输出文件名为 <code>libmymalloc.so</code>，其中 <code>.so</code> 表示共享对象文件（Shared Object）的后缀名。</li><li><code>mymalloc.c</code>：指定输入文件名为 <code>mymalloc.c</code>，该文件包含了需要编译成动态链接库的代码。</li><li><code>-ldl</code>：告诉编译器需要链接 <code>dl</code> 库（即动态链接库库），该库包含了 dlsym() 函数等相关函数的实现。</li></ul><p>当执行这个命令后，将会在当前目录下生成一个名为 <code>libmymalloc.so</code> 的动态链接库文件，该库包含了我们在 <code>mymalloc.c</code> 文件中定义的 <code>malloc()</code> 封装函数。用户可以使用 <code>LD_PRELOAD</code> 环境变量来加载这个动态链接库，从而覆盖掉系统默认的 <code>malloc()</code> 函数。</p></blockquote><p><strong>LD_PRELOAD</strong> :可以通过设置该环境变量，达到在加载动态库或者解析一个符号时，<strong>先</strong>从LD_PRELOAD指定的库中寻找符号的目的。</p><p>跟着操作了一番出现了Segmentation fault，查了一下我不是个例。mymalloc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span>   <span class="comment">//提供动态链接库的相关函数和类型的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size);</span><br><span class="line">   <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">   mallocp=dlsym(RTLD_NEXT,<span class="string">&quot;malloc&quot;</span>);   <span class="comment">//得到libc malloc的地址</span></span><br><span class="line">   <span class="keyword">if</span>((error=dlerror())!=<span class="literal">NULL</span>)       <span class="comment">//dlerro()检查最后一次动态链接库操作是否出现错误，如果失败则返回一个非空字符串指针赋值给error</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fputs</span>(error,<span class="built_in">stderr</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">char</span>* ptr =mallocp(size);<span class="comment">//在封装函数中调用原函数</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;malloc(%zu)=%p\n&quot;</span>,size,ptr);</span><br><span class="line">   <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                          </span><br></pre></td></tr></table></figure><p>RTLD_NEXT是一个伪句柄，表示在当前库之后的库中查找malloc，为什么是下一个库？因为当前库被LD_PRELOAD设置成了mymalloc.so</p><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230606153928.png"></p><p>错误产生的原因：malloc的反复调用，应该是类似没有终止的递归导致，这里留一个坑位，学明白了再解释。</p><p><strong>为什么出现段错误：</strong> 我们自定义的malloc函数调用了printf函数，printf函数又调用了malloc函数，malloc函数有调用printf函数，这是一个死循环，会导致栈溢出。</p><p>解决方法：避免反复调用&#x2F;使用不调用打桩函数的函数。我们设置了静态变量来检测调用malloc的情况，因为每次进入的状态是0，然后进行自增，运行到后面如果次数为1，那么一切正常，如果为2那么说明此时对malloc进行了第二次调用，第一次调用还没有结束，那么直接跳过printf避免它再次触发我们的malloc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span>   <span class="comment">//提供动态链接库的相关函数和类型的声明</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> calltimes;</span><br><span class="line">    calltimes++;</span><br><span class="line">   <span class="type">void</span> *(*mallocp)(<span class="type">size_t</span> size)=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="type">char</span> *error;</span><br><span class="line"></span><br><span class="line">   mallocp=dlsym(RTLD_NEXT,<span class="string">&quot;malloc&quot;</span>);   <span class="comment">//得到libc malloc的地址</span></span><br><span class="line">   <span class="keyword">if</span>((error=dlerror())!=<span class="literal">NULL</span>)       <span class="comment">//dlerro()检查最后一次动态链接库操作是否出现错误，如果失败则返回一个非空字符串指针赋值给error</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fputs</span>(error,<span class="built_in">stderr</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">char</span>* ptr =mallocp(size);<span class="comment">//在封装函数中调用原函数</span></span><br><span class="line">   <span class="keyword">if</span>(calltimes==<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;malloc(%zu)=%p\n&quot;</span>,size,ptr);   </span><br><span class="line">   &#125;</span><br><span class="line">   calltimes=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                          </span><br></pre></td></tr></table></figure><p><img src="/2024/03/21/CSAPP-%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E9%93%BE%E6%8E%A5/QQ%E6%88%AA%E5%9B%BE20230606165010.png"></p><p>只要设置 LD_PRELOAD&#x3D;”.&#x2F;mymalloc.so”，所有调用malloc函数的程序都会被改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LD_PRELOAD=./libxxx.so     #应用到全局</span><br><span class="line">unset LD_PREALOD      #取消环境变量设置</span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://www.yanbinghu.com/2019/07/28/59484.html">库打桩机制-偷梁换柱 | 守望的个人博客 (yanbinghu.com)</a></p><p><a href="https://blog.csdn.net/imred/article/details/77418323">(17条消息) CSAPP第三版运行时打桩Segmentation fault_imred的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然现在还没怎么使用过链接，因为小项目往往单个文件即可完美解决，但是当工程量大的时候，多文件操作是不可避免的。链接就是将各种代码和数据片段收集并组合成一个单一文件的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="csapp" scheme="http://example.com/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>ACTF新生赛fungame</title>
    <link href="http://example.com/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/"/>
    <id>http://example.com/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/</id>
    <published>2024-03-20T17:24:25.000Z</published>
    <updated>2024-03-20T17:24:25.039Z</updated>
    
    <content type="html"><![CDATA[<p>一道有意思又有点脑洞的re&amp;pwn题目，第一次接触到这种类型的题目，记录一下。</p><span id="more"></span><p><img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306200026.png"></p><p>很简单的异或，y1^y2即可得出16字节的input。</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Re_1s_So0_funny!</span><br></pre></td></tr></table></figure><p>虽然觉得不可思议，但还是尝试提交了一下，果不其然是错误的，然后查看y1和y2的交叉引用，看看是否出现了反调试，结果也没有。运行程序基本可以确定，这十六字节的输入是没什么问题的，因为输入其他的字符串，程序是立即结束，而输入这十六个字节，有明显的等待时间。<img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306200457.png"></p><p>接着就是查看另一个参数为input的函数，<img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306200621.png"></p><p>乍一看，没有任何的价值<img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306200713.png"></p><p>我也是查看了wp之后才注意到这里的溢出问题。</p><p>strcpy不会检测字符串的长度，因此可能发生栈溢出。而destination是十二字节，input是16字节，明显存在溢出问题，而后面的input1更是引人怀疑，交叉引用发现，被这个函数所使用<img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306201238.png"></p><p>它提示input again，然后再次对输入的字符串进行检测。一眼看出base64，解码之后是a1s0_pWn，关键的问题是如何让上面的sub_4013BA函数执行完之后不返回main函数而是这个sub_40233D。这里要借助的就是strcpy的溢出。<img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306202338.png"></p><p>destination的地址被存放在了栈顶</p><p><img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306202459.png"></p><p>进一步查看，可以找到原本的返回值</p><p><img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306202737.png"></p><p><img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306205608.png"></p><p>前十六个字节是Re_1s_So0_funny!，60FEDC那里就要用sub_40233D的地址来覆盖了，也就是0x0040233D，然后考虑小端存储最后四个字节的内容是3D、23、40，00，最后一个00不用理会，只需要填入对应的字符即可，也就是**&#x3D;#@**。</p><p><img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306203704.png"></p><p><img src="/2024/03/21/ACTF%E6%96%B0%E7%94%9F%E8%B5%9Bfungame/QQ%E6%88%AA%E5%9B%BE20240306203550.png"></p><p>所以最终的flag：Re_1s_So0_funny!&#x3D;#@a1s0_pWn</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一道有意思又有点脑洞的re&amp;amp;pwn题目，第一次接触到这种类型的题目，记录一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>2019红帽杯_snake</title>
    <link href="http://example.com/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/"/>
    <id>http://example.com/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/</id>
    <published>2024-03-20T17:22:19.000Z</published>
    <updated>2024-03-20T17:22:19.611Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240320222514.png"></p><p>Windows游戏逆向。使用到了unity框架，C#直接使用dnspy查看一下。发现没啥思路，而且是完全的陌生，于是就直接找了几个wp来研究，看完之后大有收获。</p><p>通过搜索阶段、长度、得分等关键字可以定位到关键方法。<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321003350.png"></p><p>然后就是查看这几个类，在snakehead可以找到一个和坐标相关的方法，其他的一些方法基本上根据函数名就知道函数的作用。<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321003637.png"></p><p>可以看到是从Interface调用的方法GameObject，在plugin目录有一个Interface.dll，拖入ida查看。<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321004705.png"></p><p>直接从导出函数找到GameObject。然后就是一个很难弄懂的逻辑，而且参数只有一个。但是通过定位这个关键参数<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321005342.png"></p><p><img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321005354.png"></p><p>可以确定a大于等于0，小于等于99，只有这样他才会进入那个if语句，从而有可能触发下面的函数<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321005912.png"></p><p>如果我们能用c语言把这个函数复原过来，使用0~99作为参数就可以暴破出来flag。</p><p>然而，这是一个dll文件，gameobject函数作为导出函数，是可以直接被调用的。一下是调用程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> __int64 (*Dllfunc)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dllfunc GameObject; <span class="comment">// GameObject是dll中想要调用的函数名称</span></span><br><span class="line">    HINSTANCE hdll = <span class="literal">NULL</span>;</span><br><span class="line">    hdll = LoadLibrary(TEXT(<span class="string">&quot;Interface.dll&quot;</span>)); <span class="comment">// 用LoadLibrary加载dll</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hdll == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;加载失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        GameObject = (Dllfunc)GetProcAddress(hdll, <span class="string">&quot;GameObject&quot;</span>); <span class="comment">// 到dll中定位函数</span></span><br><span class="line">        <span class="keyword">if</span> (GameObject == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;加载函数失败\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">99</span>; i++) &#123;</span><br><span class="line">                <span class="type">signed</span> __int64 res = GameObject(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FreeLibrary(hdll); <span class="comment">// 释放dll</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有可能出现加载失败的问题，这时候可以在 调式–&gt;调式属性，更改平台<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321010836.png"></p><p>因为这是一个64位的dll，所以我们的平台要选择x64<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321010848.png"></p><p>实现的效果就是</p><p><img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240321010328.png"></p><p>还有一种更为简单的调用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">dll = ctypes.cdll.LoadLibrary(<span class="string">&quot;E:\\RE\\buuctf\\Snake\\Snake_Data\\Plugins\\Interface.dll&quot;</span>)<span class="comment">#导入库</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    dll.GameObject(i)<span class="comment">#调用库函数</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>这段代码是使用Python的ctypes库加载一个名为”Interface.dll”的动态链接库，并调用其中的GameObject函数。循环100次，每次传入一个递增的整数i作为参数，并在每次调用后打印i的值。</p><p>参考链接：</p><p><a href="https://mp.weixin.qq.com/s/MKaMMihP8gPSYKswAxjNqQ">https://mp.weixin.qq.com/s/MKaMMihP8gPSYKswAxjNqQ</a></p><p>[<a href="https://blog.csdn.net/m0_46296905/article/details/116209735">2019红帽杯]Snake-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF-snake/QQ%E6%88%AA%E5%9B%BE20240320222514.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Windows游戏逆向。使用到了unity框架，C#直接使</summary>
      
    
    
    
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>2019红帽杯childRE</title>
    <link href="http://example.com/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/"/>
    <id>http://example.com/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/</id>
    <published>2024-03-20T17:22:02.000Z</published>
    <updated>2024-03-20T17:22:02.328Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/QQ%E6%88%AA%E5%9B%BE20231221035743.png"></p><p>题目逻辑并不难理解，只是遇到了船新的知识点<strong>UnDecorateSymbolName</strong>。</p><span id="more"></span><p>题目逻辑;</p><ol><li>验证输入长度是否为31</li><li>将输入打乱，其实就是将输入存储到树中</li><li>UnDecorateSymbolName函数发挥作用，得到outputstring</li><li>校验</li></ol><p>首先可以从最后的校验，得出outputstring的值，查看a4，a5两个比较数据在表a1的位置，outputstring的元素模23是a4的下标，&#x2F;23是a5的下标</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data1 = <span class="string">&#x27;(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;&#x27;</span></span><br><span class="line">data2 = <span class="string">&#x27;55565653255552225565565555243466334653663544426565555525555222&#x27;</span></span><br><span class="line">table = <span class="string">&quot;1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&#x27;ASDFGHJKL:\&quot;ZXCVBNM&lt;&gt;?zxcvbnm,./&quot;</span></span><br><span class="line"></span><br><span class="line">positions_data1 = [table.index(c) <span class="keyword">for</span> c <span class="keyword">in</span> data1 <span class="keyword">if</span> c <span class="keyword">in</span> table]</span><br><span class="line">positions_data2 = [table.index(c) <span class="keyword">for</span> c <span class="keyword">in</span> data2 <span class="keyword">if</span> c <span class="keyword">in</span> table]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data1在table中的位置：&quot;</span>, positions_data1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;data2在table中的位置：&quot;</span>, positions_data2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">62</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(positions_data1[i]+positions_data2[i]*<span class="number">23</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">//private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</span><br></pre></td></tr></table></figure><p>接下来就是由outputstring字符串反推出v5，核心是要理解UnDecorateSymbolName函数<img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/QQ%E6%88%AA%E5%9B%BE20231221040922.png"></p><p>一个函数名称经编译器修饰后会变成一段记录其各种信息（返回值、参数等）的字符串，具体规则可见<a href="https://blog.csdn.net/liweigao01/article/details/78351464">c, c++函数名编译符号修饰符说明-CSDN博客</a></p><p>UnDecorateSymbolName的函数可以根据上述字符串，还原出我们声明的函数信息</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private: char * <span class="built_in">_</span><span class="built_in">_</span>thiscall R0Pxx::My<span class="built_in">_</span>Aut0<span class="built_in">_</span>PWN(unsigned char *) 与 ?My<span class="built_in">_</span>Aut0<span class="built_in">_</span>PWN@R0Pxx@@AAEPADPAE@Z 相对应</span><br></pre></td></tr></table></figure><p>然后将字符串?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z顺序还原即可</p><p><img src="/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/QQ%E6%88%AA%E5%9B%BE20231221041743.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data11 = <span class="string">&#x27;$%8^&amp;94*(0)_-52+q=we!6rt@yu#731&#x27;</span></span><br><span class="line">data22 = <span class="string">&#x27;1234567890-=!@#$%^&amp;*()_+qwertyu&#x27;</span></span><br><span class="line">index=[]*<span class="number">31</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line"> index.append(data11.find(data22[i]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">flag0=<span class="string">&#x27;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">   <span class="built_in">print</span>(flag0[index[i]],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(flag0)</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;Z0@tRAEyuP@xAAA?M_A0_WNPx@@EPDP</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/03/21/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/QQ%E6%88%AA%E5%9B%BE20231221035743.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;题目逻辑并不难理解，只是遇到了船新的知识点&lt;strong&gt;UnDecorateSymbolName&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>OLLVM对抗</title>
    <link href="http://example.com/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/"/>
    <id>http://example.com/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/</id>
    <published>2024-03-19T13:46:13.000Z</published>
    <updated>2024-03-19T13:46:13.454Z</updated>
    
    <content type="html"><![CDATA[<p>题目：[RoarCTF2019]polyre</p><h3 id="去除控制流平坦化"><a href="#去除控制流平坦化" class="headerlink" title="去除控制流平坦化"></a>去除控制流平坦化</h3><p><img src="/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20240319205955.png"></p><span id="more"></span><p>一眼看出是控制流平坦化后的程序，可以使用deflat.py去除常规的混淆。</p><p>在配置了angr的环境运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python deflat.py attachment</span><br></pre></td></tr></table></figure><p>可以得到attachment_recovered文件。</p><h3 id="去除虚假控制流"><a href="#去除虚假控制流" class="headerlink" title="去除虚假控制流"></a>去除虚假控制流</h3><p>这是去除平坦化之后的程序</p><p><img src="/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20240319210458.png"></p><p>看流程图更明显一些<img src="/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20240319210617.png"></p><p>可以确定这是进行了虚假控制流的混淆，因为它的调转逻辑不受输入的影响，是既定的跳转，所以我们可以将那些根本没执行过的指令nop掉。借助ida trace可以清晰明了的知道哪些执行过，哪些是假的。<img src="/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20240319211142.png"></p><p>执行过的代码块都进行了高亮处理，只需将为执行的部分nop掉然后重新解析即可。<img src="/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20240319211349.png"></p><p>反编译后逻辑很简单<img src="/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20240319211857.png"></p><p>验证输入，首先判断大于零还是小于零，也就是检测最高位是否为1，如果小于零，也就是最高位为1，那么乘2也就是左移一位，再异或上一个数。如果最高位为0，那么仅左移一位。</p><p>逆向过程就是判断最低位，直接左移的最低位为0。由于异或的数据最低位为1，所以经异或处理，最低位为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> cpdata[<span class="number">7</span>] = &#123;<span class="number">0xBC8FF26D43536296</span>, <span class="number">0x520100780530EE16</span>, <span class="number">0x4DC0B5EA935F08EC</span>, <span class="number">0x342B90AFD853F450</span>, <span class="number">0x8B250EBCAA2C3681</span>, <span class="number">0x55759F81A2C68AE4</span>, <span class="number">0xB0004B7679FA26B3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> tmp=cpdata[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">64</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&amp;<span class="number">0x1</span>==<span class="number">1</span>)  <span class="comment">//末位为1</span></span><br><span class="line">            &#123;</span><br><span class="line">               tmp=((tmp^<span class="number">0xB0004B7679FA26B3</span>)&gt;&gt;<span class="number">1</span>)|<span class="number">0x8000000000000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               tmp=tmp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cpdata[i]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%llx,&quot;</span>,cpdata[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0x6666367b67616c66,0x63362d3039333932,0x2d363563342d3032,0x3539612d30376162,0x6631643365383537,0x7d38,0x1,</span></span><br></pre></td></tr></table></figure><p>最后大小端反转一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> v[<span class="number">7</span>] = &#123;<span class="number">0x6666367b67616c66</span>,<span class="number">0x63362d3039333932</span>,<span class="number">0x2d363563342d3032</span>,<span class="number">0x3539612d30376162</span>,<span class="number">0x6631643365383537</span>,<span class="number">0x7d38</span>,<span class="number">0x1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>); j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, (v[i] &gt;&gt; (j * <span class="number">8</span>)) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0x666c61677b366666,0x32393339302d3663,0x32302d346335362d,0x626137302d613935,0x3735386533643166,0x387d000000,0x10000000,</span></span><br><span class="line"><span class="comment">//flag&#123;6ff29390-6c20-4c56-ba70-a95758e3d1f8&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目：[RoarCTF2019]polyre&lt;/p&gt;
&lt;h3 id=&quot;去除控制流平坦化&quot;&gt;&lt;a href=&quot;#去除控制流平坦化&quot; class=&quot;headerlink&quot; title=&quot;去除控制流平坦化&quot;&gt;&lt;/a&gt;去除控制流平坦化&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2024/03/19/OLLVM%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20240319205955.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="OLLVM" scheme="http://example.com/tags/OLLVM/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑MZ</title>
    <link href="http://example.com/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/"/>
    <id>http://example.com/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/</id>
    <published>2024-03-19T12:55:43.000Z</published>
    <updated>2024-03-19T12:55:43.459Z</updated>
    
    <content type="html"><![CDATA[<p>题目大致三个步骤</p><p><img src="/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/QQ%E6%88%AA%E5%9B%BE20240201012211.png"></p><p>长度检测，置换，对比sha1值。</p><span id="more"></span><p>SHA1那里很容易可以从chatgpt那里得出。</p><p><img src="/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/QQ%E6%88%AA%E5%9B%BE20240201012344.png"></p><p>最关键的就是要搞清楚中间的置换逻辑。至于为什么有一个sha1检测，我首先想到的就是多解，也就是根据那个逻辑能得出多种组合，而这里只取其中一个。（当时出题就是没有考虑多解，后来经提醒想到可以用哈希值来固定答案）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">48</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = input[i];</span><br><span class="line">    v5 = off_B69000[<span class="number">2</span> * v6];</span><br><span class="line">    <span class="keyword">if</span> ( v6 - <span class="number">5</span> == v5 )                         <span class="comment">// 需要满足input[i]-5==cpdata[2*input[i]]</span></span><br><span class="line">    &#123;</span><br><span class="line">      v9[i] = ~(v6 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v6 + <span class="number">5</span> != v5 )                       <span class="comment">// 需要满足input[i]+5 == cpdata[2*input[i]]</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wrong flag\n&quot;</span>, v4);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v9[i] = ~(v6 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    off_B69000 = (<span class="type">int</span> *)off_B69000[<span class="number">2</span> * v6 + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>off_B69000是一个指针数组，input需要满足的条件是<code>input[i] -/+ 5 == off_B69000[2*input[i]]</code>,而且每次操作之后都会由<code>off_B69000 = (int *)off_B69000[2 * v6 + 1];</code>改变地址，只能采取暴破的方法。</p><p>在输入之前有一个初始化的函数</p><p><img src="/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/QQ%E6%88%AA%E5%9B%BE20240203231757.png"></p><p>他按照值、地址、值、地址的顺序赋值了5000组，这些数据就是比较数据。在数组的位置右键，点击arry然后填写数组大小即可将其解析，再将其dump出来即可。<img src="/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/QQ%E6%88%AA%E5%9B%BE20240203232711.png"></p><p>暴破脚本：</p><p>该脚本的要点在于<strong>偏移地址</strong>的计算和<strong>递归</strong>的运用。</p><p><img src="/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/QQ%E6%88%AA%E5%9B%BE20240206023917.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line"> <span class="type">char</span> flag[<span class="number">48</span>];</span><br><span class="line"> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> base)</span>;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">printStr</span><span class="params">(<span class="type">char</span>*str,<span class="type">int</span> maxlen)</span>;</span><br><span class="line"> <span class="type">int</span> offset=<span class="number">0</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> arr[<span class="number">10000</span>] = &#123;…………&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    fun(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStr</span><span class="params">(<span class="type">char</span>*str,<span class="type">int</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">strlen</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(flag[<span class="built_in">strlen</span>]!=<span class="string">&#x27;\0&#x27;</span>&amp;&amp;<span class="built_in">strlen</span>&lt;maxlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,flag[<span class="built_in">strlen</span>]);</span><br><span class="line">        <span class="built_in">strlen</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==<span class="number">48</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[<span class="number">8</span>]!=<span class="string">&#x27;s&#x27;</span>||flag[<span class="number">15</span>]!=<span class="string">&#x27;e&#x27;</span>||flag[<span class="number">18</span>]!=<span class="string">&#x27;5&#x27;</span>||flag[<span class="number">23</span>]!=<span class="string">&#x27;e&#x27;</span>||flag[<span class="number">33</span>]!=<span class="string">&#x27;t&#x27;</span>||flag[<span class="number">38</span>]!=<span class="string">&#x27;n&#x27;</span>||flag[<span class="number">45</span>]!=<span class="string">&#x27;t&#x27;</span>)<span class="comment">//这里是依次追加上的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printStr(flag,<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> chr=<span class="number">33</span>;chr&lt;<span class="number">127</span>;chr++)  <span class="comment">//利用可见字符进行暴破</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((chr+<span class="number">5</span>==arr[chr*<span class="number">2</span>+offset])||(chr<span class="number">-5</span>==arr[chr*<span class="number">2</span>+offset]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> orgoffset=offset; <span class="comment">//保存原始偏移</span></span><br><span class="line">            offset=arr[chr*<span class="number">2</span>+<span class="number">1</span>+offset];  <span class="comment">//记录下一次偏移</span></span><br><span class="line">            <span class="type">int</span> result=offset;    </span><br><span class="line">            </span><br><span class="line">            result-=<span class="number">0x299078</span>;     <span class="comment">//实际偏移  299078</span></span><br><span class="line">            offset=(result/<span class="number">4</span>);    <span class="comment">//因为dump的数据是int类型，四字节大小，所以将得到的相对偏移除4       </span></span><br><span class="line">            flag[index]=chr;      <span class="comment">//将符合的结果放入flag数组</span></span><br><span class="line">            </span><br><span class="line">            fun(index+<span class="number">1</span>);</span><br><span class="line">            offset=orgoffset;     <span class="comment">//还原初始偏移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Somet1mes_ch0ice_i5_more_import@nt_tHan_effort~!</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/QQ%E6%88%AA%E5%9B%BE20240205000051.png"></p><p>参考：</p><p><a href="https://www.bilibili.com/video/BV1wU421f78W/?spm_id_from=333.337.search-card.all.click&vd_source=edc820e8f9bd6b2ea43cb8499151dea3">2024年西湖论剑逆向Reverse题目MZ分析_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1JC411z7WL/?vd_source=edc820e8f9bd6b2ea43cb8499151dea3">【CTF&amp;RE】2024西湖论剑–MZ_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目大致三个步骤&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/03/19/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91MZ/QQ%E6%88%AA%E5%9B%BE20240201012211.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;长度检测，置换，对比sha1值。&lt;/p&gt;</summary>
    
    
    
    
    <category term="WP" scheme="http://example.com/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>花指令实现与对抗</title>
    <link href="http://example.com/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/"/>
    <id>http://example.com/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/</id>
    <published>2024-03-19T12:55:06.000Z</published>
    <updated>2024-03-19T12:55:06.601Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>花指令（junk code）是一种专门用来迷惑反编译器的指令片段，这些指令片段不会影响程序的原有功能，但会使得反汇编器的结果出现偏差，从而使破解者分析失败。比较经典的花指令技巧有利用 <code>jmp</code> 、<code>call</code>、<code>ret</code> 指令改变执行流，从而使得反汇编器解析出与运行时不相符的错误代码。</p><p>—CTF Wiki</p></blockquote><p>简单来讲花指令分为两大类，一种是会被执行的花指令，另一种是不会被执行的花指令。</p><p>花指令出现的意义就是干扰机器进行反汇编，迫使人工进行分析。</p><span id="more"></span><h3 id="不会被执行的花指令"><a href="#不会被执行的花指令" class="headerlink" title="不会被执行的花指令"></a>不会被执行的花指令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> (</span><br><span class="line">        <span class="string">&quot;xor %eax,%eax;&quot;</span></span><br><span class="line">        <span class="string">&quot;jz s;&quot;</span></span><br><span class="line">        <span class="string">&quot;add $0x11,%esp;&quot;</span>     <span class="comment">//让ida误认为栈不平衡，实则根本没有执行</span></span><br><span class="line">        <span class="string">&quot;s:;&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,junkcode\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联汇编的语法，语句放在（）内，每条指令被””包裹，以分号结尾，如果要使用寄存器则要在寄存器前加上**%<strong>，如果使用立即数则在前面加上</strong>$**。</p><p><img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128012521.png"></p><p>可以看到上方爆红。在汇编界面，直接将红框里的内容nop掉<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128012625.png"></p><p>修复后如下<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128012800.png"></p><h3 id="可以执行的花指令"><a href="#可以执行的花指令" class="headerlink" title="可以执行的花指令"></a>可以执行的花指令</h3><h4 id="破坏栈"><a href="#破坏栈" class="headerlink" title="破坏栈"></a>破坏栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> (</span><br><span class="line">        <span class="string">&quot;call next;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;next:\n&quot;</span></span><br><span class="line">        <span class="string">&quot;movl $continue,(%esp);\n&quot;</span></span><br><span class="line">        <span class="string">&quot;ret;\n&quot;</span></span><br><span class="line">        <span class="string">&quot;continue:\n&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,junkcodes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联汇编的内容实际上就是使用call进行跳转，实现的效果就是跳转到continue打印hello,junkcodes。这样为什么能使ida异常呢？我的理解是：call可以看作是push ip + jmp 指令，ret可以看作是pop ip指令，第一个call next在我们看来相当于一个简单的jmp跳转到了下一条指令，而ida肯定会将它当作函数进行分析，函数内执行了**movl $continue,(%esp);**这样一个操作，将continue的地址放入了esp寄存器中，然后ret指令将IP设为continue的地址，于是顺利执行printf指令。<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128023535.png"></p><p>也就是在ret指令执行过后，esp并没有复原，但是不影响程序运行，这就导致ida认为堆栈不平衡，导致不能反汇编。我们直接将这样的垃圾指令nop掉即可<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128023758.png"></p><p>然后f5一下即可<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128023834.png"></p><p>代码从之前的</p><p><img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128023927.png"></p><p>变为了</p><p><img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231128023948.png"></p><p>参考：<a href="https://nnnewb.github.io/blog/p/learning-packer-07/">https://nnnewb.github.io/blog/p/learning-packer-07/</a></p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>在vs上，选择x86，编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">call sub7</span><br><span class="line">_emit <span class="number">0xE8</span></span><br><span class="line">jmp label7</span><br><span class="line">sub7 :</span><br><span class="line">add dword ptr[esp], <span class="number">1</span></span><br><span class="line">retn</span><br><span class="line">label7 :</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个emit相当于汇编中的<strong>db</strong>，作用是在当前位置直接插入数据，而我们插入的0xE8是call指令的机器码，于是紧挨着的几个字节会被当作地址处处理，这会导致反汇编的失败。</p><p>这段代码的逻辑：调用sub7，执行add dword ptr[esp], 1，给[esp]+1，而【esp】保存的是call下面一条指令也就是_emit 0xE8的地址，经过这样的操作，在执行retn语句的时候，不会返回_emit 0xE8而是直接执行下面的jmp label7，于是程序正常运行。<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231129151334.png"></p><p>直接把红框部分nop掉,然后在这个位置按下U也就是undefine<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231129165105.png"></p><p>然后再按下c，将数据解析为代码，按下p创建函数，最后F5即可。<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231129165256.png"></p><p>赏心悦目<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231129165314.png"></p><p>话有一种方法是将E8后面的数据给还原，源代码我们知道，E8后面是一条跳转指令，而不应该像现在这样被解析为数据，在此处按下U<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231129165430.png"></p><p>光标放在这个位置按下C<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231129165601.png"></p><p>得到<img src="/2024/03/19/%E8%8A%B1%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AF%B9%E6%8A%97/QQ%E6%88%AA%E5%9B%BE20231129165632.png"></p><p>woc，又不行了（刚才不知道为什么阴差阳错这种办法也行），无语了。。。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;花指令（junk code）是一种专门用来迷惑反编译器的指令片段，这些指令片段不会影响程序的原有功能，但会使得反汇编器的结果出现偏差，从而使破解者分析失败。比较经典的花指令技巧有利用 &lt;code&gt;jmp&lt;/code&gt; 、&lt;code&gt;call&lt;/code&gt;、&lt;code&gt;ret&lt;/code&gt; 指令改变执行流，从而使得反汇编器解析出与运行时不相符的错误代码。&lt;/p&gt;
&lt;p&gt;—CTF Wiki&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来讲花指令分为两大类，一种是会被执行的花指令，另一种是不会被执行的花指令。&lt;/p&gt;
&lt;p&gt;花指令出现的意义就是干扰机器进行反汇编，迫使人工进行分析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="花指令" scheme="http://example.com/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>DUBHEctf_Destination</title>
    <link href="http://example.com/2024/03/19/DUBHEctf-Destination/"/>
    <id>http://example.com/2024/03/19/DUBHEctf-Destination/</id>
    <published>2024-03-19T12:53:24.000Z</published>
    <updated>2024-03-19T12:53:24.027Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319002958.png"></p><span id="more"></span><p><img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319003154.png"></p><p>没有看到加密过程，能确定的就是input和cpdata，初步判断，猫腻应该在debugbreak那里。动调一下，直接退出，是有反调试。断点下在输入之前</p><p>，还是直接闪退。查看一下main函数之前做了什么。<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319003947.png"></p><p>经过查看，可以定位到scrt_common_main函数有反调试，<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319004317.png"></p><p>在这个函数中，可以看到36行调用了invoke_main函数，而invoke_main调用了main函数，所以任务很简单，让其执行到这里即可。经过单步调试发现，在执行完26行之后，程序就卡死了，尝试了一下将这条指令nop掉，成功。然后保存文件。</p><p><img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319010513.png"></p><p>在读取完四十五字节的输入之后，有一个int 3的系统调用，而在此之前，还自定义了int 3的处理函数，也就是sub_4140d7,<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319010709.png"></p><p>经动调分析，这里就是主加密部分了，这一段是不能反编译的，因为参杂着大量的花指令，一类是利用call的假跳转<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319010910.png"></p><p>另一类是jz、jnz的永真跳转</p><p><img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319011213.png"></p><p>动态跟了数条指令之后猜测可能是tea加密，因为有几条指令是按位移动</p><p><img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319011350.png"></p><p><img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319011438.png"></p><p>可以发现规律，每一个基本块中只有一条是真正的指令，其余的要么是花指令，要么是跳转指令。可以利用trace将执行部分高亮处理，然后将其余部分nop掉。</p><p>选择instruction trace，然后一直f8<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319012403.png"></p><p>执行到很长时间不再提示将数据解析为代码时，就差不多了，此时就可以比较轻松的去除花指令和无效数据了，但是由于大量的跳转，我猜测有可能f5失败。另一种方法就是提取所有的有效指令，对于上图，有效指令就是xor eax，ecx，然后提取出来机器码，最终将所有的机器码提取出来，再patch进去。从最开始的<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319013551.png"></p><p>提取一个push ebp机器码是0x55，然后忽略jmp指令的机器码，来到下一个块，同样只提取一条有用的指令……最后patch到push ebp的位置<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319014005.png"></p><p>然后按p解析成函数，<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319014308.png"></p><p>正如我们的猜测，是xxtea</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//unsigned int v1[12]=&#123;0x9e549543,0x5e7cb348,0xd9a84a2f,0x85eb99de,0xb6825884,0xc4f74ea1,0x22b1828a,0x290d7296,0x198ee473,0x9655b529,0x38ac196a,0x192b6236&#125;;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1[<span class="number">12</span>]=&#123;<span class="number">0xc44ea811</span>,<span class="number">0xd98ae0d6</span>,<span class="number">0x984227d4</span>,<span class="number">0x1080a783</span>,<span class="number">0xf994d294</span>,<span class="number">0xc4ce08ce</span>,<span class="number">0x3d40ab34</span>,<span class="number">0x97960549</span>,<span class="number">0xfbae12d0</span>,<span class="number">0xb776de91</span>,<span class="number">0x4a3f6dd3</span>,<span class="number">0xb115b2e9</span>&#125;;</span><br><span class="line">  <span class="comment">//unsigned int v1[12]=&#123;&#125;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> key[]=&#123;<span class="number">0x6B0E7A6B</span>, <span class="number">0xD13011EE</span>, <span class="number">0xA7E12C6D</span>, <span class="number">0xC199ACA6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> z;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> myrounds =<span class="number">50</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sum=<span class="number">0x2B3AD324</span>;              </span><br><span class="line">y=v1[<span class="number">0</span>];          </span><br><span class="line"><span class="keyword">do</span>               <span class="comment">//decoding</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0xb</span>;i&gt;<span class="number">0</span>;i--)         <span class="comment">//v11    v1</span></span><br><span class="line">    &#123;</span><br><span class="line">        z=v1[i<span class="number">-1</span>];</span><br><span class="line">        y=v1[i]-=(((z ^ key[e ^ i &amp; <span class="number">3</span>]) + (y ^ sum)) ^ (((<span class="number">16</span> * z) ^ ((<span class="type">unsigned</span> <span class="type">int</span>)y &gt;&gt; <span class="number">3</span>)) + ((<span class="number">4</span> * y) ^ (z &gt;&gt; <span class="number">5</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">    z=v1[<span class="number">11</span>];         <span class="comment">// v0        z v11   y v1</span></span><br><span class="line">    y=v1[<span class="number">0</span>]-=(((z ^ key[e ^ i &amp; <span class="number">3</span>]) + (y ^ sum)) ^ (((<span class="number">16</span> * z) ^ ((<span class="type">unsigned</span> <span class="type">int</span>)y &gt;&gt; <span class="number">3</span>)) + ((<span class="number">4</span> * y) ^ (z &gt;&gt; <span class="number">5</span>))));</span><br><span class="line">    sum+=<span class="number">0x5B4B9F9E</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (--myrounds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x,&quot;</span>,v1[i]);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来以为这就结束了，拿比较数据操作的一遍，果然没这么简单。在22mu师傅的不断摸索下，发现调用完这个xxtea之后，esp又落到了函数的开始，也就是xxtea被连续调用了两次。然后就是尝试两次解密，还是不对。</p><p>这时候就开始考虑反调试修改数据之类的了，在以前的比赛因为反调试栽过不少跟头，基本上对xxtea的每一个变量都进行了交叉引用，没发现什么异常。然后返回一开始查看，发现input那里存在一处可疑的交叉引用。<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319015134.png"></p><p>代码量很少，但是很诡异<img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319015305.png"></p><p>可以说没有人类逻辑。</p><p>3cly师傅靠着题目刚开始的提示“ HEAVEN or HELL?”，在看雪发现了<a href="https://taardisaa.github.io/2021/09/25/Heaven'sGate/">天堂之门技术 | Taardis’s blog (taardisaa.github.io)</a></p><p>这篇文章，就是在32位程序运行64位的代码，将这个函数dump下来，随便找一个64位的程序patch进去</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">558BEC81ECC00000005356578BFD33C9B8CCCCCCCCF3AB5756415641574831FF8B34BDA83442004D31F64989F749C1EF1F4983FF01750AD1E681F62F97A684EB02D1E649FFC64983FE2075DE8934BDA834420048FFC74883FF0C75C4415F415E5E5F6A2368F379410048CB</span><br></pre></td></tr></table></figure><p><img src="/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319015748.png"></p><p>简单明了了，首先判断符号位，如果为1，先右移一位，在异或。如果不为1，则直接右移一位。这里的异或数据末尾为1，所以和右移一位后（最低位为0）的数据异或后末尾为1。直接右移的末尾为0。可以根据此将32位还原</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cpdata[<span class="number">12</span>] = &#123;<span class="number">0xA790FAD6</span>, <span class="number">0xE8C8A277</span>, <span class="number">0xCF0384FA</span>, <span class="number">0x2E6C7FD7</span>, <span class="number">0x6D33968B</span>, <span class="number">0x5B57C227</span>, <span class="number">0x653CA65E</span>, <span class="number">0x85C6F1FC</span>, <span class="number">0xE1F32577</span>, <span class="number">0xD4D7AE76</span>, <span class="number">0x3FAF6DC4</span>, <span class="number">0x0D599D8C</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span>  <span class="type">int</span> tmp=cpdata[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp&amp;<span class="number">0x1</span>==<span class="number">1</span>)  <span class="comment">//末位为1</span></span><br><span class="line">            &#123;</span><br><span class="line">               tmp=((tmp^<span class="number">0x84A6972F</span>)&gt;&gt;<span class="number">1</span>)|<span class="number">0x80000000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               tmp=tmp&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cpdata[i]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%x,&quot;</span>,cpdata[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x9e549543,0x5e7cb348,0xd9a84a2f,0x85eb99de,0xb6825884,0xc4f74ea1,0x22b1828a,0x290d7296,0x198ee473,0x9655b529,0x38ac196a,0x192b6236</span></span><br></pre></td></tr></table></figure><p>加密逻辑：xxtea –&gt;xxtea—&gt;位操作</p><p>解密逻辑：位操作–&gt;xxtea–&gt;xxtea</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//第一次填充从上面的位操作得出来的数据，第二次操作填充上一次xxtea的解密结果</span></span><br><span class="line">  <span class="comment">//unsigned int v1[12]=&#123;0x9e549543,0x5e7cb348,0xd9a84a2f,0x85eb99de,0xb6825884,0xc4f74ea1,0x22b1828a,0x290d7296,0x198ee473,0x9655b529,0x38ac196a,0x192b6236&#125;;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1[<span class="number">12</span>]=&#123;<span class="number">0xc44ea811</span>,<span class="number">0xd98ae0d6</span>,<span class="number">0x984227d4</span>,<span class="number">0x1080a783</span>,<span class="number">0xf994d294</span>,<span class="number">0xc4ce08ce</span>,<span class="number">0x3d40ab34</span>,<span class="number">0x97960549</span>,<span class="number">0xfbae12d0</span>,<span class="number">0xb776de91</span>,<span class="number">0x4a3f6dd3</span>,<span class="number">0xb115b2e9</span>&#125;;</span><br><span class="line">  <span class="comment">//unsigned int v1[12]=&#123;&#125;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> key[]=&#123;<span class="number">0x6B0E7A6B</span>, <span class="number">0xD13011EE</span>, <span class="number">0xA7E12C6D</span>, <span class="number">0xC199ACA6</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> z;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> myrounds =<span class="number">50</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> sum=<span class="number">0x2B3AD324</span>;              </span><br><span class="line">y=v1[<span class="number">0</span>];          </span><br><span class="line"><span class="keyword">do</span>               <span class="comment">//decoding</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0xb</span>;i&gt;<span class="number">0</span>;i--)         <span class="comment">//v11    v1</span></span><br><span class="line">    &#123;</span><br><span class="line">        z=v1[i<span class="number">-1</span>];</span><br><span class="line">        y=v1[i]-=(((z ^ key[e ^ i &amp; <span class="number">3</span>]) + (y ^ sum)) ^ (((<span class="number">16</span> * z) ^ ((<span class="type">unsigned</span> <span class="type">int</span>)y &gt;&gt; <span class="number">3</span>)) + ((<span class="number">4</span> * y) ^ (z &gt;&gt; <span class="number">5</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">    z=v1[<span class="number">11</span>];         <span class="comment">// v0        z v11   y v1</span></span><br><span class="line">    y=v1[<span class="number">0</span>]-=(((z ^ key[e ^ i &amp; <span class="number">3</span>]) + (y ^ sum)) ^ (((<span class="number">16</span> * z) ^ ((<span class="type">unsigned</span> <span class="type">int</span>)y &gt;&gt; <span class="number">3</span>)) + ((<span class="number">4</span> * y) ^ (z &gt;&gt; <span class="number">5</span>))));</span><br><span class="line">    sum+=<span class="number">0x5B4B9F9E</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (--myrounds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x,&quot;</span>,v1[i]);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x68627544,0x46544365,0x6532387b,0x66336531,0x35382d38,0x36346566,0x382d6639,0x64393934,0x2d383464,0x61363634,0x30366439,0x7d</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换大小端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v[<span class="number">12</span>] = &#123;<span class="number">0x68627544</span>,<span class="number">0x46544365</span>,<span class="number">0x6532387b</span>,<span class="number">0x66336531</span>,<span class="number">0x35382d38</span>,<span class="number">0x36346566</span>,<span class="number">0x382d6639</span>,<span class="number">0x64393934</span>,<span class="number">0x2d383464</span>,<span class="number">0x61363634</span>,<span class="number">0x30366439</span>,<span class="number">0x7d</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>); j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, (v[i] &gt;&gt; (j * <span class="number">8</span>)) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DubheCTF&#123;82e1e3f8-85fe469f-8499dd48-466a9d60&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/03/19/DUBHEctf-Destination/QQ%E6%88%AA%E5%9B%BE20240319002958.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>idapython用法</title>
    <link href="http://example.com/2024/03/13/idapython%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2024/03/13/idapython%E7%94%A8%E6%B3%95/</id>
    <published>2024-03-12T17:10:13.000Z</published>
    <updated>2024-03-12T17:10:13.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="去除简单的花指令"><a href="#去除简单的花指令" class="headerlink" title="去除简单的花指令"></a>去除简单的花指令</h3><p>在main函数存在多个这样的花指令<img src="/2024/03/13/idapython%E7%94%A8%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20240301201158.png"></p><p>永真跳转导致ida解析失败，只需要将jz、jnz那里nop掉即可</p><span id="more"></span>![](idapython用法/QQ截图20240301202407.png)<p>也就是红框框住的部分，将这五个字节的内容全部填充为nop（0x90）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">start=<span class="number">0x4005BF</span></span><br><span class="line">end=<span class="number">0x401DA2</span></span><br><span class="line"></span><br><span class="line">strlen=end-start</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(strlen):</span><br><span class="line">  curaddr=start+index</span><br><span class="line">  tmpValue0=idc.get_wide_dword(curaddr)</span><br><span class="line">  <span class="keyword">if</span>(tmpValue0==<span class="number">0x01750374</span>):    <span class="comment">#注意小端序</span></span><br><span class="line">     <span class="built_in">print</span>(curaddr)</span><br><span class="line">     ida_bytes.patch_dword(curaddr,<span class="number">0x90909090</span>)</span><br><span class="line">     ida_bytes.patch_byte(curaddr+<span class="number">4</span>,<span class="number">0x90</span>)</span><br><span class="line">     <span class="comment">#没有找到更简洁的方法，参考wp是直接用的replace 没有找到那个api</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="idapthon与smc"><a href="#idapthon与smc" class="headerlink" title="idapthon与smc"></a>idapthon与smc</h3><p><img src="/2024/03/13/idapython%E7%94%A8%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20240313010043.png"></p><p>逻辑很简单，就是将一段长度为0x39的数据异或上一个固定的数值，动态调试的话也很容易，只是工作量有点大，使用idapython会很舒服。</p><p>思路就是根据<strong>相对距离</strong>读取数据进行patch</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">start=<span class="number">0x140001000</span></span><br><span class="line">end=<span class="number">0x140001460</span></span><br><span class="line"></span><br><span class="line">strlen=end-start</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(strlen):</span><br><span class="line">  curaddr=start+index</span><br><span class="line">  tmpValue=idc.get_wide_dword(curaddr)</span><br><span class="line">  <span class="keyword">if</span>(tmpValue==<span class="number">0x39FA8348</span>):      <span class="comment">#小端序 cmp rdx,39h</span></span><br><span class="line">     <span class="built_in">print</span>(curaddr)</span><br><span class="line">     xorData=idc.get_wide_byte(curaddr-<span class="number">4</span>)           <span class="comment">#异或的数据</span></span><br><span class="line">     <span class="built_in">print</span>(xorData)</span><br><span class="line">     <span class="keyword">for</span> index1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x39</span>):</span><br><span class="line">           data=idc.get_wide_byte(curaddr+<span class="number">6</span>+index1)</span><br><span class="line">           ida_bytes.patch_byte(curaddr+<span class="number">6</span>+index1,(xorData^data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ok&quot;</span>)</span><br></pre></td></tr></table></figure><p>刚开始写反了几个小错误，这里着重记录一下.</p><p>获取数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idc.get_wide_byte(address)</span><br><span class="line"></span><br><span class="line">idc.get_wide_word(address)</span><br><span class="line"></span><br><span class="line">idc.get_wide_dword(address)</span><br></pre></td></tr></table></figure><p>patch：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ida_bytes.patch_byte(address,data)</span><br><span class="line"></span><br><span class="line">ida_bytes.patch_word(address,data)</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;去除简单的花指令&quot;&gt;&lt;a href=&quot;#去除简单的花指令&quot; class=&quot;headerlink&quot; title=&quot;去除简单的花指令&quot;&gt;&lt;/a&gt;去除简单的花指令&lt;/h3&gt;&lt;p&gt;在main函数存在多个这样的花指令&lt;img src=&quot;/2024/03/13/idapython%E7%94%A8%E6%B3%95/QQ%E6%88%AA%E5%9B%BE20240301201158.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;永真跳转导致ida解析失败，只需要将jz、jnz那里nop掉即可&lt;/p&gt;</summary>
    
    
    
    
    <category term="idapython" scheme="http://example.com/tags/idapython/"/>
    
  </entry>
  
  <entry>
    <title>OLLVM进阶</title>
    <link href="http://example.com/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/</id>
    <published>2024-01-09T16:10:10.000Z</published>
    <updated>2024-01-09T16:11:00.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="控制流扁平化"><a href="#控制流扁平化" class="headerlink" title="控制流扁平化"></a>控制流扁平化</h3><p>目的是展平程序的控制流程图。</p><p>测试源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>gcc编译：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240110000230.png"></p><p>clang-4.0 -mllvm -fla -mllvm -split -mllvm -split_num&#x3D;3 test01.c -o test01混淆：</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240110000220.png"></p><p>大量的while构成的无限循环，可读性十分差<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240110000428.png"></p><h3 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a>虚假控制流</h3><blockquote><p>此方法通过在当前基本块之前添加一个基本块来修改函数调用图。这个新的基本块包含一个不透明的谓词，然后有条件地跳转到原始的基本块。</p><p>原始的基本块也被克隆并填充了随机选择的垃圾指令。</p></blockquote><p><strong>不透明谓词：</strong>指的是<strong>一个表达式</strong>，它的值是确定的，但是对于分析者，程序不执行到特定位置是个很难知道真假的。静态分析器也无法推断出这个值。<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223155.png"></p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223232.png"></p><p><a href="https://www.zhihu.com/question/46259412">(9 封私信 &#x2F; 80 条消息) 利用不透明谓词混淆代码的原理是什么？ - 知乎 (zhihu.com)</a></p><p>测试源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc直接编译得到：</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223351.png"></p><p>流程图：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223415.png"></p><p>clang -mllvm -bcf选项处理编译：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223527.png"></p><p>流程图：<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109223546.png"></p><p>这里的不透明谓词是</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( y &gt;= <span class="number">10</span> &amp;&amp; (((<span class="name">x</span> - <span class="number">1</span>) * x) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br></pre></td></tr></table></figure><p>((x - 1) * x)奇数乘偶数，得到的必然是偶数，偶数二进制形式最低位必然为0，所以不满足不等于0，&amp;&amp;的右侧表达式结果必然为假，无论y取何值，do while都不会执行第二次。</p><h3 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h3><p>可以实现加法、减法、和、或、异或的替换。也就是说可以把简单的运算用一种复杂的方法实现。</p><p>源码：</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109171021.png"></p><p>先用gcc编译得到一个参考对照程序，就是c&#x3D;a+b</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109170749.png"></p><p>经过**-sub**选项处理</p><p><img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109170810.png"></p><p>ecx存放5，edx存放3，esi存放0，esi&#x3D;esi-ecx （-5），ecx存放0，ecx&#x3D;ecx-edx（-3）,esi&#x3D;esi+ecx，（-8）eax&#x3D;eax-esi（8），实现的效果就是5+3–&gt;-((-5)+(-3))<img src="/2024/01/10/OLLVM%E8%BF%9B%E9%98%B6/QQ%E6%88%AA%E5%9B%BE20240109172441.png"></p><p><strong>-mllvm -sub_loop&#x3D;x</strong></p><p>使用该选项可以实现指定处理的次数x。</p><p>下一篇文章介绍如何对抗ollvm混淆。</p><p>参考：<a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening">Control Flow Flattening · obfuscator-llvm&#x2F;obfuscator Wiki · GitHub</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;控制流扁平化&quot;&gt;&lt;a href=&quot;#控制流扁平化&quot; class=&quot;headerlink&quot; title=&quot;控制流扁平化&quot;&gt;&lt;/a&gt;控制流扁平化&lt;/h3&gt;&lt;p&gt;目的是展平程序的控制流程图。&lt;/p&gt;
&lt;p&gt;测试源码：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; a = atoi(argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="OLLVM" scheme="http://example.com/tags/OLLVM/"/>
    
  </entry>
  
  <entry>
    <title>初识OLLVM</title>
    <link href="http://example.com/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/"/>
    <id>http://example.com/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/</id>
    <published>2023-12-30T14:07:03.000Z</published>
    <updated>2024-01-09T08:22:46.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OLLVM"><a href="#OLLVM" class="headerlink" title="OLLVM"></a>OLLVM</h3><p>OLLVM是一个基于LLVM的框架的混淆器，主要功能有三：指令替换、混淆控制流、控制流平坦化。一言以蔽之，ollvm可以用来混淆程序，增加逆向难度。</p><span id="more"></span><h3 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h3><p>那么什么是LLVM呢？LLVM（low level virtual machine）是一个编译器框架，是一系列模块化、可重用的编译器及工具链技术的集合。</p><p><img src="/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20231230213344.png"></p><p>通过这张图，可以很好的理解llvm的作用。</p><p>第一部分：Clang作为前端接收C（各种语言）源文件，生成中间代码IR<img src="/2023/12/30/%E5%88%9D%E8%AF%86OLLVM/QQ%E6%88%AA%E5%9B%BE20231230213931.png"></p><p>第二部分：中间代码IR经pass的优化处理得到新的IR，不同的PASS对应不同的优化</p><p>第三部分：生成机器码</p><h3 id="OLLVM原理"><a href="#OLLVM原理" class="headerlink" title="OLLVM原理"></a>OLLVM原理</h3><p>费这么大篇幅介绍LLVM肯定是有用的，前面讲了OLLVM是基于LLVM，最大的区别在于PASS不同，我的理解是LLVM的pass是用来优化的，而OLLVM的PASS是用来混淆的。</p><h3 id="OLLVM的环境搭建"><a href="#OLLVM的环境搭建" class="headerlink" title="OLLVM的环境搭建"></a>OLLVM的环境搭建</h3><p>涉及到gcc、g++以及各种环境，建议直接在Ubuntu使用docker一步到位</p><p><a href="https://www.bilibili.com/read/cv13148903/">跟着铁头干混淆3 ubuntu下用docker编译ollvm(保证成功) - 哔哩哔哩 (bilibili.com)</a></p><h3 id="OLLVM的使用"><a href="#OLLVM的使用" class="headerlink" title="OLLVM的使用"></a>OLLVM的使用</h3><h4 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h4><p>可用选项：</p><ul><li>-mllvm -fla : 激活控制流平坦化</li><li>-mllvm -split : 激活基本块分割</li><li>-mllvm -split_num&#x3D;3 : 指定基本块分割的数目</li></ul><p>语法</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang 选项一 选项二 选项<span class="built_in">N</span> 原码 -o 可执行文件</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -fla test.c -o test</span><br></pre></td></tr></table></figure><h4 id="虚假控制流"><a href="#虚假控制流" class="headerlink" title="虚假控制流"></a>虚假控制流</h4><p>可用选项：</p><ul><li>-mllvm -bcf : 激活虚假控制流</li><li>-mllvm -bcf_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1</li><li>-mllvm -bcf_prob&#x3D;40 : 每个基本块被混淆的概率，这里每个基本块被混淆的概率为40%，默认为 30 %</li></ul><p>语法同上</p><h4 id="指令替换"><a href="#指令替换" class="headerlink" title="指令替换"></a>指令替换</h4><p>可用选项：</p><ul><li>-mllvm -sub : 激活指令替代</li><li>-mllvm -sub_loop&#x3D;3 : 混淆次数，这里一个函数会被混淆3次，默认为 1次</li></ul><p>语法同上</p><p>下一篇文章介绍各个混淆实现的效果。</p><p>参考链接：</p><p><a href="https://jev0n.com/2022/07/07/ollvm-0.html">OLLVM混淆学习（0）——环境搭建及混淆初体验 - 思泉 | Jev0n</a></p><p><a href="https://www.cnblogs.com/lqerio/p/16009042.html#Clang">LLVM 简介 （一） - Erio - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;OLLVM&quot;&gt;&lt;a href=&quot;#OLLVM&quot; class=&quot;headerlink&quot; title=&quot;OLLVM&quot;&gt;&lt;/a&gt;OLLVM&lt;/h3&gt;&lt;p&gt;OLLVM是一个基于LLVM的框架的混淆器，主要功能有三：指令替换、混淆控制流、控制流平坦化。一言以蔽之，ollvm可以用来混淆程序，增加逆向难度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="OLLVM" scheme="http://example.com/tags/OLLVM/"/>
    
  </entry>
  
  <entry>
    <title>Java疑难杂症</title>
    <link href="http://example.com/2023/11/19/Java%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    <id>http://example.com/2023/11/19/Java%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</id>
    <published>2023-11-19T13:48:04.000Z</published>
    <updated>2023-11-20T06:16:18.528Z</updated>
    
    <content type="html"><![CDATA[<p>跟着GitHub上的 27天成为java大神 项目学习Java。</p><h3 id="损失精度"><a href="#损失精度" class="headerlink" title="损失精度"></a>损失精度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line"><span class="type">short</span> s=<span class="number">1</span>, s = s+<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> s=<span class="number">1</span>, s+=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">上面两个代码有没有问题，如果有，那里有问题</span><br></pre></td></tr></table></figure><span id="more"></span><p>第一个是存在问题的，java默认类型是int， <code>s = s+1</code>里的1就是int类型的，所以等号右边的s+1会被转化成int类型，而一个int类型的值要赋值给short类型的变量，就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      s += <span class="number">1</span>; </span><br><span class="line"><span class="comment">//这个是没有问题的。</span></span><br><span class="line"><span class="comment">//因为这个式子等价于：</span></span><br><span class="line"><span class="comment">// s = (s的数据类型)(s + 1);</span></span><br></pre></td></tr></table></figure><h3 id="逻辑右移与算数右移"><a href="#逻辑右移与算数右移" class="headerlink" title="逻辑右移与算数右移"></a>逻辑右移与算数右移</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;    <span class="comment">//算数右移，最高位补符号位</span></span><br><span class="line">&gt;&gt;&gt;   <span class="comment">//逻辑右移，最后高位补零</span></span><br><span class="line">此处的-<span class="number">1</span>为<span class="type">int</span>类型，<span class="number">32</span>位    </span><br><span class="line">-<span class="number">1</span>&gt;&gt;<span class="number">1</span> =<span class="number">1111</span> <span class="number">1111</span> = -<span class="number">1</span></span><br><span class="line">-<span class="number">1</span>&gt;&gt;&gt;<span class="number">1</span>=<span class="number">0111</span> <span class="number">1111</span> = <span class="number">2147483647</span> max</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">1</span> 原码：<span class="number">1000 0001</span></span><br><span class="line">   反码：<span class="number">1111 1110</span></span><br><span class="line">   补码：<span class="number">1111 1111</span>     </span><br></pre></td></tr></table></figure><h3 id="打印数组名"><a href="#打印数组名" class="headerlink" title="打印数组名"></a>打印数组名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">System.out.println(arr);      <span class="comment">//[I@2f92e0f4</span></span><br><span class="line"></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);   <span class="comment">//0</span></span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);   <span class="comment">//0</span></span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未初始化的数组被编译器初始化为0，打印arr出现字符串**[I@2f92e0f4**其中 [ 代表该数据为数组，I 代表数据类型是int，后面的是地址。</p><p>特殊的，如果打印的是一个char数组命，则会直接打印出数组内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] arr=<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(arr);          <span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为方法的重载，public void println(char[] x) 是直接打印出内容，其余几个类型是打印地址。</p><h3 id="java中只有值传递"><a href="#java中只有值传递" class="headerlink" title="java中只有值传递"></a>java中只有值传递</h3><p>如果想通过方法修改数组可以传递地址，也就是数组名。</p><h3 id="this的本质"><a href="#this的本质" class="headerlink" title="this的本质"></a>this的本质</h3><p>this的本质：代表方法<strong>调用者</strong>的<strong>地址值</strong></p><h3 id="float与long"><a href="#float与long" class="headerlink" title="float与long"></a>float与long</h3><p>long类型的数据后面要加上L或l，float类ing的数据后面要加上f或F，因为整数类型默认是int，浮点类型默认是double。</p><h3 id="Java中的内存分配"><a href="#Java中的内存分配" class="headerlink" title="Java中的内存分配"></a>Java中的内存分配</h3><p>程序在运行时需要在内存分配空间为了提高效率，对空间进行了划分。</p><ul><li>栈 存储局部变量</li><li>堆  存储new出来的东西</li><li>方法区</li><li>本地方法区</li><li>寄存器</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>Java中的静态关键字，类中的<strong>变量</strong>&#x2F;<strong>方法</strong>被static修饰，则可以被所有对象<strong>共享</strong>。并且被static修饰的成员可以直接通过类名进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(<span class="string">&quot;hahahah&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Students s=<span class="keyword">new</span> <span class="title class_">Students</span>();</span><br><span class="line">        s.show();</span><br><span class="line">        <span class="comment">//直接通过类名调用</span></span><br><span class="line">        Student.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在静态方法中没有this关键字，因为静态是<strong>随着类的加载而加载的</strong>（存放在堆中的静态区），优先于对象进入内存，而this是随着对象进入内存的，先进内存的不能访问后进内存的，而后进入内存的可以访问先进入内存的。</p><p><strong>静态只能访问静态</strong>，静态的成员方法只能访问静态成员变量和静态的成员方法，非静态的成员方法则可以访问所有。</p><h3 id="变量的就近原则"><a href="#变量的就近原则" class="headerlink" title="变量的就近原则"></a>变量的就近原则</h3><p>使用变量的时候会优先找局部范围，如果想直接使用成员变量可以使用this关键字。及承建的成员变量也符合这个规则，如果想使用父类的成员变量可以使用super关键字。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类会默认调用父类的无参构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExtendDemo</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">666</span>;</span><br><span class="line">    Zi z=<span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="number">666</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">     System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出是什么？是666吗，不，是father 666，这是为什么呢？？？？因为在调用子类的构造方法输出666之前先调用了父类的无参构造方法，要想只输出666有两种方法，<strong>第一种</strong>是清空父类的所有构造方法，如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Fu</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样父类会有一个默认的Fu{},没有影响，特别注意的是就算Fu类定义成下面这个样子也是不行的，因为编译器检测到存在构造方法，就不会自动添加一个无参构造方法，这样子类在调用父类的构造方法时就会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是使用super关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">     <span class="built_in">super</span>(a);</span><br><span class="line">     System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super(…)关键字可以访问父类的带参构造方法，this(…)访问本类的构造方法。</p><h3 id="方法重载与方法重写"><a href="#方法重载与方法重写" class="headerlink" title="方法重载与方法重写"></a>方法重载与方法重写</h3><p><strong>方法重写 override</strong> 发生在子类与父类之间，当子类与父类方法声明相同时就发生了方法重写，返回值类型、参数列表不可改变。</p><p>**方法重载 overload ** 发生在同一个类中，当方法名相同但是参数列表不相同时就发生了重载，重载可以使用不同的返回值类型。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态可以理解为一个事物的多种形态，比如水，有固体水、液体水、气体水，可以定义一个水类，固液气采用继承的方式来创建新的类，这样既有了水的共性，又有各自的特性。我上面的表达不就是继承吗？哈，这样说似乎也没什么问题，多态的三个必要条件就是：继承、方法重写、<strong>父类指向子类对象。</strong>继承是多态的前提。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类指向子类对象</span></span><br><span class="line">Father fa= <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure><p>对于多态<strong>成员变量</strong>：编译、运行看左边</p><p>看左边指的就是左边的 fa</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> age=<span class="number">44</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age=<span class="number">22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类类型 对象 = new 子类类型 ()</span></span><br><span class="line">        Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(fa.age); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果,也就是左边的Father类中的age</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">44</span><br></pre></td></tr></table></figure><p>对于多态<strong>成员方法</strong>：编译看左边，运行看右边。</p><p>这里的编译，也就是在运行前，我们写出来，编译器就会检测，如果有错误就不能运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;爸爸吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;儿子吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Demo&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类类型 对象 = new 子类类型 ()</span></span><br><span class="line">        Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        fa.eat();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面一句会报错 </span></span><br><span class="line">        <span class="comment">//The method paly() is undefined for the type Father Java(67108964)</span></span><br><span class="line">        fa.paly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然实际运行时使用的是子类的方法，但是在编译阶段，看的左边的父类，父类中没有这个方法，所以直接编译不通过。父类无法调用子类独有的方法，如何解决这个问题？有两种方案，其一是在父类中增加一个空的play方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;爸爸吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其二是<strong>引用类型转换</strong></p><h4 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h4><h5 id="向上转型-自动转换"><a href="#向上转型-自动转换" class="headerlink" title="向上转型(自动转换)"></a>向上转型(自动转换)</h5><p>子类向父类转型，可以理解为儿子变为父亲。父类引用指向一个子类对象，就是向上转型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fteher fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure><p>父类有很多子类，而子类却只有一个父类，所以向上转型是自动的.</p><h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><p>父类向子类转型，需要强制转换，也就是指定转换类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line"><span class="comment">//子类类型 子类变量名 =(子类类型) 父类变量名</span></span><br><span class="line">Son fa2=(Son) fa;</span><br><span class="line">fa2.play();</span><br></pre></td></tr></table></figure><p>在完成向下转型后，fa2的变量是子类的，方法是子类与父类的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">44</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;爸爸吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fish</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;爸爸钓鱼&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="type">int</span> age=<span class="number">22</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;儿子吃饭&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;儿子玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//父类类型 对象 = new 子类类型 ()</span></span><br><span class="line">        Father fa=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        fa.eat();</span><br><span class="line">        <span class="comment">//下面一句会报错</span></span><br><span class="line">        Son fa1=(Son) fa;</span><br><span class="line">        System.out.println(fa1.age);</span><br><span class="line">        fa1.fish();</span><br><span class="line">        fa1.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">爸爸吃饭</span><br><span class="line">22</span><br><span class="line">爸爸钓鱼</span><br><span class="line">儿子玩游戏</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;跟着GitHub上的 27天成为java大神 项目学习Java。&lt;/p&gt;
&lt;h3 id=&quot;损失精度&quot;&gt;&lt;a href=&quot;#损失精度&quot; class=&quot;headerlink&quot; title=&quot;损失精度&quot;&gt;&lt;/a&gt;损失精度&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;面试题：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;type&quot;&gt;short&lt;/span&gt; s=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, s = s+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;short&lt;/span&gt; s=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, s+=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		上面两个代码有没有问题，如果有，那里有问题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="language" scheme="http://example.com/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（考试篇）</title>
    <link href="http://example.com/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/</id>
    <published>2023-11-19T13:46:37.000Z</published>
    <updated>2023-11-19T13:46:37.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的先序遍历、后序遍历、中序遍历"><a href="#二叉树的先序遍历、后序遍历、中序遍历" class="headerlink" title="二叉树的先序遍历、后序遍历、中序遍历"></a>二叉树的先序遍历、后序遍历、中序遍历</h3><p><strong>先序遍历：</strong>根节点—&gt;左节点–&gt;右节点</p><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108092718.png"></p><span id="more"></span><p>这个过程是递归的，比如说访问了左节点B之后不是去访问右节点C，而是去访问了以B为根节点的左节点D。顺序有个规律，可以看作是这个小人逆时针跑了一圈：A B D H I E J E C F K G</p><p><strong>后序遍历：</strong>左节点–&gt;右节点–&gt;根节点</p><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108093513.png"></p><p>按照递归<strong>左右根</strong>就能排出来，排序小技巧是如图所示，当成一串葡萄，逆时针剪下最外面的一个单一葡萄。</p><p><strong>中序遍历：</strong>左节点–&gt;根节点–&gt;右节点</p><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108094014.png"></p><p>小技巧是看作竖直方向上的投影，其顺序是：HDIBEJAFKCG</p><p>参考：<a href="https://blog.csdn.net/chinesekobe/article/details/110874773">数据结构——二叉树先序、中序、后序及层次四种遍历（C语言版）_中序遍历-CSDN博客</a></p><h3 id="度、节点计算"><a href="#度、节点计算" class="headerlink" title="度、节点计算"></a><strong>度、节点计算</strong></h3><p><strong>入度</strong>为0则为根节点，其余节点入度为1</p><p><strong>出度</strong>则是子节点的个数，可取0、1、2。</p><p>总入度&#x3D;节点总数-1，总入度&#x3D;总出度</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">记节点出度为0、1、2的节点数分别为n0、n1、n2</span><br><span class="line">则总出度<span class="attribute">N</span>=n1+n2*2</span><br><span class="line">总结点数=n0+n1+n2</span><br><span class="line">根据 总入度=节点总数-1，总入度=总出度</span><br><span class="line">则n0+n1+<span class="attribute">n2-1</span>=n2*2+n1</span><br><span class="line">所以<span class="attribute">n0</span>=n2+1</span><br></pre></td></tr></table></figure><p>一棵二叉树有十个度为2的节点，5个度为1的节点，求节点总数。10*2+5&#x3D;n-1     n&#x3D;25+1&#x3D;26   26&#x3D;15&#x3D;11     </p><p>节点总数等于度1+度2+度0，因此求出度为0的节点即可，即度2+1，所以10+1&#x3D;11个。</p><p>参考：<a href="https://blog.csdn.net/qq_41126936/article/details/126539411">【精选】二叉树——度以及节点数的计算_二叉树节点和度的计算_不想做咸鱼的霉霉的博客-CSDN博客</a></p><h3 id="计算时间复杂度"><a href="#计算时间复杂度" class="headerlink" title="计算时间复杂度"></a>计算时间复杂度</h3><ul><li>用常数1取代所有加法常数 O(199)—-&gt;O(1)</li><li>只保留最高阶O(n^2+n)—&gt;O(n^2)</li><li>去除最高阶常数O(2*N^2)—-&gt;O(N^2)</li></ul><p><img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108104447.png"></p><p>O(2*N+10)—-&gt;O(N)</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">下面程序段的时间复杂度为（）。</span><br><span class="line"></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span><span class="comment">(i&lt;=n)</span></span><br><span class="line"></span><br><span class="line">i=i*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">(A)</span> O<span class="comment">(n)</span>       <span class="comment">(B)</span> O<span class="comment">(3n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(C)</span> O<span class="comment">(log3n)</span>   <span class="comment">(D)</span> O<span class="comment">(n3)</span></span><br></pre></td></tr></table></figure><p>正确答案是c，3^log3n&#x3D;n。</p><h3 id="存取结构"><a href="#存取结构" class="headerlink" title="存取结构"></a>存取结构</h3><p>顺序存取和随机存取</p><p><strong>随机存取（Random Access）</strong>，指的是当存储器中的数据被读取或写入时，所需要的时间与该数据所在的物理地址无关，数组采用的就是随机存取，通过下标进行存取，存取arr[1]和存取arr[100]没有时间上的区别</p><p><strong>顺序存取（Sequential access）</strong>是一种按记录的逻辑顺序进行读写操作的存取方法，所需的时间与数据所在的位置有关。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>顺序、链式、索引、哈希存储，后三个可以归为随机存储。</p><h4 id="顺序存储："><a href="#顺序存储：" class="headerlink" title="顺序存储："></a>顺序存储：</h4><p>相邻的数据存储在物理位置上相邻的存储单元。</p><p>优点：节省存储空间、可以实现随机存取</p><p>缺点：修改不方便、产生磁盘碎片</p><p><strong>随机存储：</strong></p><p>相邻的数据物理位置可以不相邻。</p><p>优点：不会产生磁盘碎片、修改数据方便</p><p>缺点：占用空间大、查找时比顺序存储慢，且只能实现顺序存取</p><h3 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h3><p><strong>树</strong>是一种非线性数据结构，树由唯一的根和若干互不相交的子树组成。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115095442.png"></p><p><strong>森林</strong>是树的集合。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115095612.png"></p><p><strong>树到二叉树</strong>的转化规则是：左孩子右兄弟。每个节点左指针指向第一个孩子，右指针指向他在树中相邻的兄弟。根节点没有兄弟，所以对应的二叉树无右子树。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115101837.png"></p><p>森林到二叉树，先将森林里的每棵树转为二叉树，然后再第一棵树转换的二叉树的右子树接上第二棵树转化的二叉树。<img src="/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115102215.png"></p><p>参考：<a href="https://blog.csdn.net/mynaiskey/article/details/124842989">树、森林与二叉树的转换_已知树的结点数怎么求森林的左右子数-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;二叉树的先序遍历、后序遍历、中序遍历&quot;&gt;&lt;a href=&quot;#二叉树的先序遍历、后序遍历、中序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的先序遍历、后序遍历、中序遍历&quot;&gt;&lt;/a&gt;二叉树的先序遍历、后序遍历、中序遍历&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;先序遍历：&lt;/strong&gt;根节点—&amp;gt;左节点–&amp;gt;右节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2023/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E8%80%83%E8%AF%95%E7%AF%87%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231108092718.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（一）</title>
    <link href="http://example.com/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-11-19T13:44:59.000Z</published>
    <updated>2023-11-19T13:44:59.840Z</updated>
    
    <content type="html"><![CDATA[<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p>指的是操作系统中的<strong>网络控制软件</strong>。</p><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字的实体就是<strong>通信控制信息</strong>，在协议栈的内部有一块专门用于存储控制信息的内存空间，具体是什么呢？通信对象的IP、端口号、通信状态等。协议栈是根据套接字中记录的控制信息来工作的。在终端使用netstat命令显示套接字内容<img src="/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115020243.png"></p><span id="more"></span><p>上图的每一行实际上就相当于一个套接字，拿一个具体的来说</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TCP</span>    <span class="number">192.168.101.101:53369</span>  <span class="number">39.137.107.210</span>:https   ESTABLISHED     <span class="number">11844</span></span><br></pre></td></tr></table></figure><p>PID为11844的程序正在使用IP地址为192.168.101.101的网卡与IP地址为39.137.107.210的对象进行通信，http指代特定端口，53369是本机使用的端口。</p><p>通信操作中使用的<strong>控制信息</strong>分为两类。 </p><p>（1）头部中记录的信息 </p><p>（2）套接字（协议栈中的内存空间）中记录的信息</p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><p>创建套接字时，首先分配一个套接字所需的内存空间，然后向其 中写入初始状态。</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><p>创建套接字后，应用程序调用connect，随后协议栈将本地的套接字与服务器的套接字进行<strong>连接</strong>。这里的连接指的是通信双方交换控制信息。客户端会将IP地址和端口号等信息告知服务器。</p><h4 id="连接的具体操作"><a href="#连接的具体操作" class="headerlink" title="连接的具体操作"></a>连接的具体操作</h4><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect（<span class="attribute">&lt; 描述符 &gt;</span>, <span class="attribute">&lt; 服务器 IP 地址和端口号 &gt;</span>, …）</span><br></pre></td></tr></table></figure><p>客户端会创建一个包含表示开始数据收发操作的控制信息<strong>头部</strong>，其中最重点的部分是接收方和发送方的端口号。<img src="/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115022815.png"></p><p>随后头部的SYN会被设置为1表示连接。到此TCP头部创建好了，接下来TCP模块会将信息传递给IP模块。IP模块负责执行网络包的收发操作，网络包经IP模块通过网络到达服务器，服务器的IP模块将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部信息找到端口号对应的套接字。接下来服务器的TCP模块工作流程和上述客户端工作流程相同。网络包到达客户端后会通过IP模块到达TCP模块，并通过头部信息确认连接是否成功，如果SYN为1则代表成功，这时会向套接字中写入服务器的IP地址和端口号等信息。</p><p>我们可以认为连接完毕后有一个管子将客户端和服务器的两个套接字连接起来了，往后通过这根管子收发数据。连接操作完成后控制流被交回到应用程序。</p><h3 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h3><p>连接完成后进入收发阶段。应用程序首先会调用write将要发送的数据交给协议栈，协议栈收到数据后执行发送操作。</p><p>协议栈并不是已收到数据就进行发送操作的，这样会产生大量的小网络包，导致网络效率下降。通常会累计一定的数据长度才会发送。说到长度，有两个比较重要的参数：</p><p><strong>MTU</strong>：一个网络包的最大长度，以太网中一般为 1500 字节。 </p><p><strong>MSS</strong>：除去头部之后，一个网络包所能容纳的 TCP 数据的最大 长度。</p><p>如果数据长度很大，则会被拆分会若干个块<img src="/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115030254.png"></p><h4 id="确认信息是否到达"><a href="#确认信息是否到达" class="headerlink" title="确认信息是否到达"></a>确认信息是否到达</h4><p>通过“序号”和“ACK 号”可以确认接收方是否收到了网络包。</p><p><strong>ACK号：</strong>与头部相对距离。</p><h3 id="断开并删除套接字"><a href="#断开并删除套接字" class="headerlink" title="断开并删除套接字"></a>断开并删除套接字</h3><p>客户端应用程序调用close断开到戒子，结束数据收发操作。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;协议栈&quot;&gt;&lt;a href=&quot;#协议栈&quot; class=&quot;headerlink&quot; title=&quot;协议栈&quot;&gt;&lt;/a&gt;协议栈&lt;/h3&gt;&lt;p&gt;指的是操作系统中的&lt;strong&gt;网络控制软件&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;套接字&quot;&gt;&lt;a href=&quot;#套接字&quot; class=&quot;headerlink&quot; title=&quot;套接字&quot;&gt;&lt;/a&gt;套接字&lt;/h3&gt;&lt;p&gt;套接字的实体就是&lt;strong&gt;通信控制信息&lt;/strong&gt;，在协议栈的内部有一块专门用于存储控制信息的内存空间，具体是什么呢？通信对象的IP、端口号、通信状态等。协议栈是根据套接字中记录的控制信息来工作的。在终端使用netstat命令显示套接字内容&lt;img src=&quot;/2023/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231115020243.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ecercism本地搭建即上传</title>
    <link href="http://example.com/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/"/>
    <id>http://example.com/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/</id>
    <published>2023-11-02T18:09:08.000Z</published>
    <updated>2023-11-02T18:09:08.074Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://exercism.org/">exercism</a>一个界面简洁，功能强大的开源学习平台，目前已经支持67种语言的学习。<img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103015318.png"></p><span id="more"></span><p>最近想学一下Android安全，Java课上也没好好听，于是来这里学习一下Java，学习路线是看书+实践，书是《Java基础核心总结》相当的短小精悍，实践就是在exercism这个平台上了。</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><p>第一种是使用<strong>在线</strong>的编辑器：很好用，就是打开的时候卡卡的，于是就选择了在本地搭建。</p><p>第二种本地环境：这里是详细的教程<a href="https://exercism.org/docs/using/solving-exercises/working-locally">Working Locally | Exercism’s Docs</a>，主要记录一下如何下载题目和上传。</p><h4 id="题目的下载"><a href="#题目的下载" class="headerlink" title="题目的下载"></a>题目的下载</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exercism download --exercise=lasagna --track=java</span><br></pre></td></tr></table></figure><p>下载命令在每个练习的右侧</p><p><img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020216.png"></p><p>直接复制在终端运行即可</p><p><img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020323.png"></p><h4 id="题目的上传"><a href="#题目的上传" class="headerlink" title="题目的上传"></a><strong>题目的上传</strong></h4><p>我们用vscode直接打开刚才下载好的那个文件夹，在src&#x2F;main目录下找到我们要修改的源文件，补充并保存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exercism submit src/main/java/Lasagna.java</span><br></pre></td></tr></table></figure><p>这个命令不用记，在每个题目附件的help文档都能找到<img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020608.png"></p><p>运行结果如下<img src="/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103020742.png"></p><p>点击下方链接即可查看结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://exercism.org/&quot;&gt;exercism&lt;/a&gt;一个界面简洁，功能强大的开源学习平台，目前已经支持67种语言的学习。&lt;img src=&quot;/2023/11/03/ecercism%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E5%8D%B3%E4%B8%8A%E4%BC%A0/QQ%E6%88%AA%E5%9B%BE20231103015318.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="language" scheme="http://example.com/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>rust入门（一）</title>
    <link href="http://example.com/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-10-15T15:36:38.000Z</published>
    <updated>2023-10-15T15:36:38.494Z</updated>
    
    <content type="html"><![CDATA[<p>听闻rust大名已久，正巧赶上2023 秋冬季开源操作系统训练营，就来学习啦。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello,world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>从最经典的打印hello world开始，可以看到和c语言比较像，都是在main函数中执行，不同的是不需要头文件，而且打印方法非常的多元。</p><h3 id="println！"><a href="#println！" class="headerlink" title="println！"></a>println！</h3><p>这样，从这个方法，可以看出 <strong>{}</strong> 相当于c语言中的占位符 <strong>%d</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#125; &quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;s&#125; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是可以正常打印出<code>Hello world</code>的。</p><p>这里提一嘴rust的编译，非常的简单，在终端源码目录下运行，即可得到一个可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure><h3 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h3><p>！！！Rust的变量是默认不可变的 这就非常的反直觉，不过这会使得程序变得更加安全，变量用let来声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"> x=<span class="number">6</span></span><br><span class="line"></span><br><span class="line"> x=x+<span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231012210247.png"></p><p>下面两条试图改变变量x的语句都是不合法的，要想使变量真正可变，需要在创建时加上一个mut （mutable，可变的）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> =<span class="number">5</span>;</span><br><span class="line">x=<span class="number">6</span>;</span><br><span class="line">x=x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量总是不可变的，使用const而不是let声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CON: <span class="type">u32</span>=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在这条语句中，const表示声明一个常量，CON是名称，u32是常量的类型即无符号32位整数，常量必须是在编译阶段已经确定的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CON： <span class="type">u32</span>=<span class="number">3</span>+<span class="number">3</span>+<span class="number">3</span> ；   <span class="comment">//编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CON： <span class="type">u32</span>=x+<span class="number">1</span>；      <span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p>常量的命名规则，单词全大写并且用_连接。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231012211348.png"></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>和c语言的结构体很像，可以存储不同类型的值，引用方面比较奇怪。</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013015009.png"></p><p>元组的引用方法</p><p>方法一</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>=(<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (_x,y,_z)=tup;   <span class="comment">//这一步把元组里的三个数据分别赋值给了x，y，z,在x前加上_告诉编译器x是有意不使用的，这样就不会发出warning</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y=&#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//y=6.4</span></span><br></pre></td></tr></table></figure><p>方法二 索引</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>=(<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y=&#123;&#125;&quot;</span>,tup.<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//y=500  索引下标从零开始</span></span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013020329.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>:[<span class="type">i32</span>;<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//a是名字，[]里是类型 有符号32位整数 分号后面的5表示长度为5</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=&#123;<span class="number">3</span>;<span class="number">5</span>&#125;<span class="comment">//申请一个长度为5全部填充3的数组</span></span><br></pre></td></tr></table></figure><p>输出数组，通过这个输出可以看出print之后是默认换行的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>:[<span class="type">i32</span>; <span class="number">5</span>]= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>命名规则单词全部小写，函数的声明可以在程序的任何位置</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013021625.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">aaa</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">aaa</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//xxx</span></span><br></pre></td></tr></table></figure><p>含有参数的函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">aaa</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">aaa</span>(x:<span class="type">i32</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=5</span></span><br></pre></td></tr></table></figure><p>含有返回值的函数，返回值需要显示地表示出来</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span>=<span class="title function_ invoke__">aaa</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;aaa return &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">aaa</span>(x:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=5</span></span><br><span class="line"><span class="comment">//aaa return 6</span></span><br></pre></td></tr></table></figure><p>对，我没有写错，最后一行6的后面就是没有分号，我们可以这样理解：最后一行<code>6</code>是一个常量<strong>表达式</strong>，它的值等于整数<code>6</code>。在这个函数中，它被用作返回值。</p><ul><li>表达式：先这么记，代码没有分号则是一个表达式，表达式会返回值，可以用来赋值</li><li>语句 <code>let 1:i32=5</code>; 这就是一个语句，无返回值。</li></ul><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013023912.png"></p><p>需要注意的是if后面的判断表达式返回值必须是bool值。</p><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013024308.png"></p><p>就然还有loop，我只在汇编中接触过loop，可以从loop中返回一个值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span>:<span class="type">i32</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=<span class="keyword">loop</span>&#123;</span><br><span class="line">        a+=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> a&gt;<span class="number">3</span>&#123;</span><br><span class="line">            <span class="keyword">break</span> a;  <span class="comment">//跳出循环返回a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//x=4</span></span><br></pre></td></tr></table></figure><p>loop中break和continue的用法和c语言类似。</p><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p>作用是精确的退出多层循环。</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013030215.png"></p><h4 id="while和for循环"><a href="#while和for循环" class="headerlink" title="while和for循环"></a>while和for循环</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013030332.png"></p><h3 id="所有权概念"><a href="#所有权概念" class="headerlink" title="所有权概念"></a>所有权概念</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013124018.png" alt=" "></p><h3 id="这里存在疑问！！！！！！！！！！！！！！！！！！"><a href="#这里存在疑问！！！！！！！！！！！！！！！！！！" class="headerlink" title="这里存在疑问！！！！！！！！！！！！！！！！！！"></a>这里存在疑问！！！！！！！！！！！！！！！！！！</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=<span class="number">123</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>=x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y=&#123;&#125;&quot;</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=123</span></span><br><span class="line"><span class="comment">//y=123</span></span><br></pre></td></tr></table></figure><p>按照对所有权的介绍，打印x的时候x应该已经弃用了。</p><h3 id="变量作用域与变量隐藏"><a href="#变量作用域与变量隐藏" class="headerlink" title="变量作用域与变量隐藏"></a>变量作用域与变量隐藏</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013165838.png"></p><p>**{}**是作用域，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=<span class="number">122</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>=x+<span class="number">1</span>;   <span class="comment">//变量隐藏</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span>=<span class="number">124</span>;              <span class="comment">//x的作用域</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);     <span class="comment">//x的作用域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x=&#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x=124</span></span><br><span class="line"><span class="comment">//x=123</span></span><br></pre></td></tr></table></figure><h3 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h3><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013175951.png"></p><p>s和s1的关系如下图所示。&amp;是引用符号</p><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013180621.png"></p><p>首先s不是指向hello字符串的，所以不存在与s1竞争所有权的问题，其次离开s的作用域后s丢弃，s1以及hello字符串不受影响。</p><h3 id="rustlings记录"><a href="#rustlings记录" class="headerlink" title="rustlings记录"></a>rustlings记录</h3><h4 id="关于if"><a href="#关于if" class="headerlink" title="关于if"></a>关于if</h4><p><img src="/2023/10/15/rust%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231013205305.png"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bigger</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a&gt;b&#123;</span><br><span class="line">    a</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> a&lt;b&#123;</span><br><span class="line">    b</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//note: `if` expressions without `else` evaluate to `()`</span></span><br><span class="line"><span class="comment">//help: consider adding an `else` block that evaluates to the expected type</span></span><br></pre></td></tr></table></figure><p><strong>if语句必须跟一个else语句</strong></p><h4 id="slice-切片"><a href="#slice-切片" class="headerlink" title="slice 切片"></a>slice 切片</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">slice_out_of_array</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nice_slice</span> = &amp;a[<span class="number">1</span>..<span class="number">4</span>];  <span class="comment">//从下标 1 至下标 4-1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], nice_slice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone和借用"><a href="#clone和借用" class="headerlink" title="clone和借用"></a>clone和借用</h3><p><strong>clone</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1: &#123;&#125;&quot;</span>, s1); <span class="comment">// 此处仍然可以使用s1</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s2: &#123;&#125;&quot;</span>, s2); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p><code>clone</code>是用于创建数据的完全拷贝，包括堆上的数据。它会复制原始数据，生成一个新的独立副本，两者之间没有关联。<code>clone</code>适用于需要独立拥有数据的情况，确保对数据的修改不会影响原始数据。</p><p><strong>借用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_length</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Length: &#123;&#125;&quot;</span>, s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">print_length</span>(&amp;s); <span class="comment">// 传递s的引用给函数，不会转移所有权</span></span><br></pre></td></tr></table></figure><p>借用(<code>borrowing</code>)则是一种不拥有数据但可以临时访问的机制。通过借用，可以将数据的引用传递给其他代码，而无需转移所有权。在使用借用时，原始数据保持不变，可以有多个不可变引用同时存在，但只能有一个可变引用。这样可以在编译时避免数据竞争和并发问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;听闻rust大名已久，正巧赶上2023 秋冬季开源操作系统训练营，就来学习啦。&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello,world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="language" scheme="http://example.com/tags/language/"/>
    
    <category term="rust" scheme="http://example.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Android学习篇（二）</title>
    <link href="http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2023-10-15T11:15:42.000Z</published>
    <updated>2023-10-15T11:15:42.691Z</updated>
    
    <content type="html"><![CDATA[<p>主要学习smali，通过实际上手修改smali代码加深理解。</p><span id="more"></span><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM是Java虚拟机，运行Java字节码程序。</p><h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>Dalvik是Google专门为Android设计的一个虚拟机，Dalvik有专属的文件执行格式dex(Dalvik executable)。</p><h3 id="smali及其语法"><a href="#smali及其语法" class="headerlink" title="smali及其语法"></a>smali及其语法</h3><p>smali是Dalvik的寄存器语言，smali代码是dex反编译而来的。可以把Dalvik理解成x86，那么smali就是x86汇编。在反编译的时候不能修改该java代码，只能修改smali代码。</p><h3 id="jadx"><a href="#jadx" class="headerlink" title="jadx"></a>jadx</h3><p>分析apk的工具，可以理解为分析java的ida。</p><h3 id="vip终结"><a href="#vip终结" class="headerlink" title="vip终结"></a>vip终结</h3><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015181533.png"></p><p>任务是一键三连，但是他弹窗提醒需要充值大会员，直接在jadx中使用搜索功能，搜索大会员。直接定位到这段代码。<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015181807.png"></p><p>首先他会判断我们的硬币数量，在判断我们是不是vip，解决方法</p><ol><li>进入这个方法之后直接goto到 ChallengeSecond challengeSecond2 &#x3D; challengeSecond;</li><li>修改硬币和isvip的判断</li><li>修改寄存器中的值</li></ol><h4 id="通过修改判断"><a href="#通过修改判断" class="headerlink" title="通过修改判断"></a>通过修改判断</h4><p>jadx不支持修改代码，要使用mt管理器，提取apk文件并定位，反编译dex文件，搜索硬币，点击进入<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015182756.png"></p><p>if-ge全称greater equal(a&gt;&#x3D;b)，a大于或等于则跳，在mt里直接修改成if-le也就是小于等于即可，这样我们就会直接跳转到标签cood_15处，下面看isvip判断<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015183442.png"></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">if</span>-eqz <span class="built_in">p0</span>, :cond_43</span><br></pre></td></tr></table></figure><p>如果p0等于0则跳转到cond_43处，而cood_43是提示请充值大会员的标签，所以我们可以选择直接注释掉这段代码，这样就不会发生跳转，或者讲逻辑改成不等于0.</p><p>保存并重新安装即可。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015184145.png"></p><h4 id="通过修改寄存器的值"><a href="#通过修改寄存器的值" class="headerlink" title="通过修改寄存器的值"></a>通过修改寄存器的值</h4><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185249.png"></p><p>p0是我们的硬币数量，v0被赋成了10，我们只需要将 const&#x2F;16 v0, 0xa改成 const&#x2F;16 v0, 0x0即可。下面跳转到isvip判断，长按点击跳转<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185439.png"></p><p>逻辑是这样的<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185509.png"></p><p>也就是返回0即假，直接const&#x2F;4 v0,0x1即可</p><h4 id="强制跳转"><a href="#强制跳转" class="headerlink" title="强制跳转"></a>强制跳转</h4><p>看一下goto的用法</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015185904.png"></p><p>直接照着葫芦画瓢</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015190518.png"></p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015190620.png"></p><p>成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;主要学习smali，通过实际上手修改smali代码加深理解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android逆向" scheme="http://example.com/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Android学习篇（一）</title>
    <link href="http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2023-10-15T11:15:34.000Z</published>
    <updated>2024-01-10T04:16:57.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Android简介"><a href="#Android简介" class="headerlink" title="Android简介"></a>Android简介</h3><p>Android是一种基于Linux的操作系统。</p><h3 id="apk"><a href="#apk" class="headerlink" title="apk"></a>apk</h3><p>APK 的全称是 Android Package，它扩展名为 .apk。APK 是 Android 应用程序的包文件格式。它是 Android 操作系统上安装应用程序的文件类型。APK 实际上是一个<strong>压缩包</strong>，其中包含了应用程序的所有文件，包括代码、资源、图像、音频和其他数据。APK 文件是将应用程序打包并分发到 Android 设备上的主要方式。在电脑上只要将.apk后缀改为7z就可以用压缩工具打开了。</p><span id="more"></span><table><thead><tr><th>文件</th><th>注释</th></tr></thead><tbody><tr><td>assets 目录</td><td>这个目录用于存放APK的静态资源文件，如视频、音频、图片等，存放的是<strong>未经编译处理</strong>的原始文件</td></tr><tr><td>lib 目录</td><td>这个目录包含了针对不同 CPU 架构的本地代码库文件。</td></tr><tr><td>META-INF 目录</td><td>这个目录包含了与 APK 文件的签名相关的信息，例如签名文件（.MF）、证书文件（.RSA 或 .DSA）等。这些文件用于验证 APK 文件的完整性和身份。</td></tr><tr><td>res 目录</td><td>用于存放编译后的资源文件的地方，例如图像、布局文件、字符串等。</td></tr><tr><td>AndroidManifest.xml 文件</td><td>这个文件是应用程序的清单文件，描述了应用程序的属性、权限、组件和其他重要信息。</td></tr><tr><td>classes.dex 文件</td><td>这个文件包含了应用程序的已编译 Java 代码，也就是Java的字节码文文件，是APK运行的主要逻辑。</td></tr><tr><td>resources.arsc 文件</td><td>这个文件是资源表文件，包含了应用程序使用的所有资源的索引和定义。</td></tr></tbody></table><h3 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h3><h4 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h4><p>描述UI，并且处理用户与机器屏幕的交互。简单来说，一个界面就是一个activity。</p><h4 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h4><p> 处理与应用程序关联的后台操作。服务试运行在后台，执行长时间操作的组件。例如后台播放音乐。</p><h4 id="BroadcastReceivers-广播接收器"><a href="#BroadcastReceivers-广播接收器" class="headerlink" title="BroadcastReceivers(广播接收器)"></a>BroadcastReceivers(广播接收器)</h4><p>处理Android操作系统和应用程序之间的通信。广播接收器简单地响应从其他应用程序或者系统发来的广播消息。举个例子，应用程序可以发起广播来让其他应用程序知道一些数据已经被下载到设备，并且可以供给他们使用。广播接收器会拦截这些通信并采取适当的行动。</p><h4 id="ContenProviders-内容提供者"><a href="#ContenProviders-内容提供者" class="headerlink" title="ContenProviders(内容提供者)"></a>ContenProviders(内容提供者)</h4><p> 处理数据和数据库管理方面的问题。</p><h3 id="MT管理器"><a href="#MT管理器" class="headerlink" title="MT管理器"></a>MT管理器</h3><p>MT管理器（MT Manager）是一款功能强大的Android文件管理器和应用程序管理工具。它提供了许多高级功能和工具，可以帮助用户对安装在Android设备上的应用程序和文件进行管理、编辑、查看和修改。</p><h3 id="双开即原理"><a href="#双开即原理" class="headerlink" title="双开即原理"></a>双开即原理</h3><p>双开即在手机上打开两个相同应用，比如打开两个微信或者QQ。一台设备通常不允许两个名字相同的应用同时运行，因此我们可以通过修改包名的方法进行双开。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014181313.png"></p><p>点击功能，点击APK共存，修改包名确定然后安装即可。最新版的np管理器不支持免费共存了，所以下载了一个旧版本，旧版本进去他会强制要求升级到最新版，然后我断开了模拟器的网络就可以正常使用了。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192339.png"></p><p>点开之后，成功运行。</p><h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>主要在后缀为arsc 、xml、dex的文件中</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015022605.png"></p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192448.png"></p><p>将程序的英文部分翻译成中文呢，直接进入课程挑战<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231014192831.png"></p><p>进入mt管理器，选择安装包之后，右上角三道杠，选择查看，点击高级搜索（全局搜索），下面文本输入hello，然后就定位到了jf.xml，通过前面的学习，我们知道了<strong>res目录</strong>用于存放编译后的资源文件的地方，例如图像、布局文件、<strong>字符串</strong>等。</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015014947.png">点击选择反编译,然后找到hello字符串修改成中文的<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015012902.png"></p><p>然后点击保存，并返回，勾选上自动签名，然后点击安装，发现安装失败，这是因为系统检测到了APK的签名发生了变化，我们可以通过卸载之前的应用避开这个问题，当然还有别的解决方案，只是现在为时尚早，就直接卸载再安装<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015014300.png"></p><p>你好 吾爱破解。</p><p>对于难以搜索的字符串，比如下面那句啥，俄语？</p><p>使用开发者助手</p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015020751.png"></p><p>可以直接复制，方法和上面类似，这一次定位到的是<strong>resources.arsc 文件</strong>  </p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021522.png"></p><p>选择翻译模式，点击上方[default]，就能找到那个字符串，点击，写在翻译后，然乎确定保存并重新安装即可，这次发现不需要卸载应用那个步骤了，因为这两次的签名都是由mt提供的一个自带的签名信息。<img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021702.png"></p><p><img src="/2023/10/15/Android%E5%AD%A6%E4%B9%A0%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/QQ%E6%88%AA%E5%9B%BE20231015021948.png"></p><h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><table><thead><tr><th align="left">属性</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">versionCode</td><td align="left">版本号，主要用来更新，例如:12</td></tr><tr><td align="left">versionName</td><td align="left">版本名，给用户看的，例如:1.2</td></tr><tr><td align="left">package</td><td align="left">包名，例如：com.zj.52pj.demo</td></tr><tr><td align="left">uses-permission android:name&#x3D;””</td><td align="left">应用权限，例如：android.permission.INTERNET 代表网络权限</td></tr><tr><td align="left">android:label&#x3D;”@string&#x2F;app_name”</td><td align="left">应用名称</td></tr><tr><td align="left">android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</td><td align="left">应用图标路径</td></tr><tr><td align="left">android:debuggable&#x3D;”true”</td><td align="left">应用是否开启debug权限</td></tr></tbody></table><p>跟着大佬学：<a href="https://www.52pojie.cn/thread-1695796-1-1.html">《安卓逆向这档事》二、初识APK文件结构、双开、汉化、基础修 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Android简介&quot;&gt;&lt;a href=&quot;#Android简介&quot; class=&quot;headerlink&quot; title=&quot;Android简介&quot;&gt;&lt;/a&gt;Android简介&lt;/h3&gt;&lt;p&gt;Android是一种基于Linux的操作系统。&lt;/p&gt;
&lt;h3 id=&quot;apk&quot;&gt;&lt;a href=&quot;#apk&quot; class=&quot;headerlink&quot; title=&quot;apk&quot;&gt;&lt;/a&gt;apk&lt;/h3&gt;&lt;p&gt;APK 的全称是 Android Package，它扩展名为 .apk。APK 是 Android 应用程序的包文件格式。它是 Android 操作系统上安装应用程序的文件类型。APK 实际上是一个&lt;strong&gt;压缩包&lt;/strong&gt;，其中包含了应用程序的所有文件，包括代码、资源、图像、音频和其他数据。APK 文件是将应用程序打包并分发到 Android 设备上的主要方式。在电脑上只要将.apk后缀改为7z就可以用压缩工具打开了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android逆向" scheme="http://example.com/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>2023柏鹭杯rev1-wp</title>
    <link href="http://example.com/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/"/>
    <id>http://example.com/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/</id>
    <published>2023-10-12T07:02:27.000Z</published>
    <updated>2023-10-12T07:02:27.367Z</updated>
    
    <content type="html"><![CDATA[<p>可以看到要求的输入长度是64个字符，前面是简单的验证输入的字符是否合规，红框圈起来的函数是主加密函数，下面可以不用分析了。</p><span id="more"></span><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011202957.png"></p><p>动态调试F7步入函数。</p><p>加密部分可以划分为三块，每一块都是用AVX2汇编实现的，类似于进行了内联汇编。这是第一部分，将我们的输入与ebp-40处开始的32个字节进行异或操作并保存到ymm0处。<img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203337.png"></p><p>第二部分是使用vphufb根据ebp-60处的32字节对ymm0处存放的数据进行重排。</p><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203404.png"></p><p>c语言代码表示vpshufb ymm0, ymm0 , index</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i <span class="operator">=</span> <span class="number">0</span><span class="comment">; i &lt; 32; ++i)</span></span><br><span class="line">   &#123;</span><br><span class="line">       ymm0[i] <span class="operator">=</span> ymm0[index[i]]<span class="comment">;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后是比较部分，ebp-20处存放的是比较数据。</p><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231011203428.png"></p><p>那么逆向过程就是：</p><ol><li>提取比较数据</li><li>重排</li><li>异或</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//加密过程</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> xordata[<span class="number">32</span>] = &#123;      <span class="comment">//异或数据，与input进行异或</span></span><br><span class="line">    <span class="number">0xCD</span>, <span class="number">0xEB</span>, <span class="number">0x5E</span>, <span class="number">0x76</span>, <span class="number">0x0F</span>, <span class="number">0x22</span>, <span class="number">0xAF</span>, <span class="number">0x31</span>, <span class="number">0x82</span>, <span class="number">0x92</span>, <span class="number">0x3C</span>, <span class="number">0xEF</span>, <span class="number">0xB8</span>, <span class="number">0xC1</span>, <span class="number">0x76</span>, <span class="number">0x06</span>, </span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0x2F</span>, <span class="number">0xB5</span>, <span class="number">0x7D</span>, <span class="number">0x7F</span>, <span class="number">0x0A</span>, <span class="number">0xEA</span>, <span class="number">0x85</span>, <span class="number">0x92</span>, <span class="number">0x00</span>, <span class="number">0x89</span>, <span class="number">0xA3</span>, <span class="number">0x2C</span>, <span class="number">0xE2</span>, <span class="number">0xE7</span>, <span class="number">0x32</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> changedata[<span class="number">32</span>] = &#123;     <span class="comment">//重排表</span></span><br><span class="line">    <span class="number">0x0A</span>, <span class="number">0x07</span>, <span class="number">0x06</span>, <span class="number">0x0E</span>, <span class="number">0x02</span>, <span class="number">0x0B</span>, <span class="number">0x03</span>, <span class="number">0x0D</span>, <span class="number">0x01</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x05</span>, <span class="number">0x04</span>, <span class="number">0x0F</span>, <span class="number">0x08</span>, <span class="number">0x0C</span>, </span><br><span class="line">    <span class="number">0x1B</span>, <span class="number">0x18</span>, <span class="number">0x17</span>, <span class="number">0x1F</span>, <span class="number">0x14</span>, <span class="number">0x1E</span>, <span class="number">0x12</span>, <span class="number">0x13</span>, <span class="number">0x15</span>, <span class="number">0x1D</span>, <span class="number">0x16</span>, <span class="number">0x1C</span>, <span class="number">0x11</span>, <span class="number">0x10</span>, <span class="number">0x19</span>, <span class="number">0x1A</span>&#125;; </span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> cmpdata[<span class="number">32</span>] = &#123;     <span class="comment">//比较数据</span></span><br><span class="line">    <span class="number">0x5F</span>, <span class="number">0x91</span>, <span class="number">0x99</span>, <span class="number">0xE8</span>, <span class="number">0x4E</span>, <span class="number">0xD0</span>, <span class="number">0xB0</span>, <span class="number">0x92</span>, <span class="number">0xB1</span>, <span class="number">0x3C</span>, <span class="number">0x4F</span>, <span class="number">0xF4</span>, <span class="number">0x17</span>, <span class="number">0x76</span>, <span class="number">0xDA</span>, <span class="number">0x12</span>, </span><br><span class="line">    <span class="number">0x2A</span>, <span class="number">0x35</span>, <span class="number">0x01</span>, <span class="number">0x15</span>, <span class="number">0xF9</span>, <span class="number">0x97</span>, <span class="number">0x5E</span>, <span class="number">0x19</span>, <span class="number">0x9D</span>, <span class="number">0xC2</span>, <span class="number">0x15</span>, <span class="number">0x99</span>, <span class="number">0x70</span>, <span class="number">0x7D</span>, <span class="number">0x9F</span>, <span class="number">0xCC</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> flag[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[changedata[<span class="number">31</span>-i]]=cmpdata[<span class="number">31</span>-i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag[j]=flag[j]^xordata[j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>,flag[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//825A10C618D636A058AE633FAA539E70655FEB648697FF84A79F4589B5207027</span></span><br><span class="line"><span class="comment">//flag&#123;ISEC-a49d6b847bdba62c5bfa0a43b69c8575&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231012145355.png"></p><p>逆向过程没啥障碍，写脚本的时候<code>flag[changedata[31-i]]=cmpdata[31-i];</code>31写成了32，造成了越界，但是非常的不明显<img src="/2023/10/12/2023%E6%9F%8F%E9%B9%AD%E6%9D%AF/QQ%E6%88%AA%E5%9B%BE20231012145647.png"></p><p>离谱的是vscode有时候能跑起来有时候跑不起来，这里记录一下，以后注意这个问题，可能需要安装一个检测这种小错误的插件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可以看到要求的输入长度是64个字符，前面是简单的验证输入的字符是否合规，红框圈起来的函数是主加密函数，下面可以不用分析了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>压缩壳原理即对坑-UPX为例</title>
    <link href="http://example.com/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/"/>
    <id>http://example.com/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/</id>
    <published>2023-10-10T18:49:22.000Z</published>
    <updated>2023-10-10T18:49:22.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h3><p>壳，分为<strong>压缩壳</strong>，<strong>保护壳</strong>，<strong>伪装壳</strong>（对抗杀毒软件）</p><p>这篇文章讲以下压缩壳，压缩壳可以有效减少程序的体积，同时由于压缩之后的代码比较难懂，所以也有一定的保护作用，最常见的就是UPX壳。压缩壳不同于一般的压缩（7zp、rar等），它不需要解压缩操作，程序可以直接运行，用到的是一种<strong>运行时解压缩</strong>技术。</p><span id="more"></span><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20230621022516.png"></p><p>运行加壳程序，操作对象是notepad.exe，运行得到new.exe程序，大小从67584变为了48128字节。</p><p>这是notepad.exe对应的</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007173949.png"></p><p>这是new.exe对应的<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007174057.png"></p><p>加入的upx代码的作用是将2、3、4解压缩（还原）为7、8、9，并不影响程序的运行。在我们运行程序的瞬间2、3、4被还原为7、8、9。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007181711.png"></p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231007182006.png"></p><p>可以看到，啥都看不到，看到的这些就是上文提到的2、3、4就是压缩之后的代码。壳可以手动脱也可以用脱壳机一键脱，当然脱不下来的话就要上手了。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><h4 id="机脱"><a href="#机脱" class="headerlink" title="机脱"></a>机脱</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">win+r</span><br><span class="line">d：/</span><br><span class="line">cd tools（upx文件夹所在的文件夹）</span><br><span class="line">cd upx</span><br><span class="line">upx.exe</span><br><span class="line">upx -d 程序名</span><br></pre></td></tr></table></figure><p>如果成功则程序直接发生更改，如果出现红色的字体则说明没有脱壳成功。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20230404113409.png"></p><h4 id="手脱"><a href="#手脱" class="headerlink" title="手脱"></a>手脱</h4><p>手脱的工具需要</p><ul><li>ollydbg</li><li>lordpe  （在xp环境，反正win11不行）</li><li>ImportREC  （修复IAT）</li></ul><p>我们将有壳的程序拖入od他会弹出这个窗口，我们知道他是有壳的，所以不需要他继续分析啦，直接点否。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010184402.png"></p><p>这段代码是壳的开始</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010184802.png"></p><p>我们知道壳的原理是运行时解压缩，壳这段操作实际上是在对压缩的原始程序进行解压随，对一段数据进行操作难免会用到循环，循环就会往上跳转，所以我们遇到向上跳转的汇编指令直接跳过，直接结束循环而不是进入循环（跳过的意思是一瞬间执行完所有循环）<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185154.png"></p><p>可以看到jb这条指令会向上跳转，我们单机下面的mov指令然后F4（运行到），同理遇到jmp，jz，jnz一旦往上跳转我么都F4，需要注意的是call指令我们也不进入而是直接跳过。原因是我们会进入call调用的那个函数，容易迷失。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185519.png"></p><p>upx以及很多壳的一个明显特征是结尾有个大跳转<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010185730.png"></p><p>跳转的这个位置25DDAC就是OEP了，然后进行dump,用到的工具是lordpe，首先右键一下当前进程，点击修复大小。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010233637.png"></p><p>然后右键选择完整转存，保存文件。运行</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231010234100.png"></p><p>哈哈哈，这是什么情况呢？我们需要修复一下IAT（import address table 导入地址表），要用到的工具是ImportREC，首先在importrec中选择未脱壳的进程(它的IAT是正确的)，注意这里的OEP要改成OPE的相对偏移地址，也就是OD看到的地址减去基地址0x400000得到1DDAC，然后点击<strong>自动查找IAT</strong>，接着<strong>获取输入表</strong>，最后选择<strong>转储到文件</strong>，转储的文件选择之前dump出来的那个文件，这就是修复IAT的过程。</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011002203.png"></p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011002614.png"></p><p>左边是脱壳之后的文件直接拖进od的结果，右边的是我们单步调试的带壳程序，并且脱完壳的程序是可以正常运行的，脱壳成功。<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011004257.png"></p><p>壳是脱完了，但是你是否有一个疑问，为什么要修复IAT?下面我们来了解一下</p><h3 id="修复IAT"><a href="#修复IAT" class="headerlink" title="修复IAT"></a>修复IAT</h3><p>来自知乎大佬的一句总结 ”不论是压缩壳还是加密壳，在脱壳过程中都需要修复IAT，因为<strong>脱壳时会将内存中的数据转储 (dump)到本地，保存成文件，而IAT在文件中是一个RVA数组，在内存中是一个函数地址数组</strong>。我们需要将转储出来的文件中的IAT修复成RVA数组的形式，这样程序才算是恢复。“ </p><p>这里接上之前学习<a href="https://fishjump-my.github.io/2023/08/23/PE%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AF%87/#more">PE的知识</a><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011011721.png"></p><p>IAT相当于一个进货清单，描述pe文件引用了哪些文件&#x2F;函数。在脱壳过程中，由于壳的修改，原来的IAT表项已经是无效的，无法正确识别真正的外部函数或模块。</p><p>修复IAT步骤：</p><ul><li>识别IAT表项：根据（未脱壳）程序的结构和特征，识别出加壳程序中被修改的IAT表项。对应的操作是”自动查询”IAT“</li><li>构建正确的IAT：根据原始的可执行文件，构建正确的IAT表项，使其能正确指向外部函数或模块。对应“获取IAT”</li><li>更新IAT表项：将构建好的IAT表项写入到程序中，覆盖原来呜嗷的表项，实现修复。对应“转储到文件”</li></ul><h3 id="OEP"><a href="#OEP" class="headerlink" title="OEP"></a>OEP</h3><p>什么是OEP呢，就是函数真正的入口。</p><p>下面我们多了解以下OEP的特征，毕竟如果不认识OEP的话，就算我们脱下了壳，也不知道自己成功了。直接偷懒截大佬们的文章了</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OEP：(Original <span class="keyword">Entry</span> Point)，程序的原始入口点。</span><br></pre></td></tr></table></figure><p><strong>VS特点</strong>：CALL和JMP,CALL进去之后调用的API是相同的<img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011022742.png"></p><p><strong>Delphi特点</strong>:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">esp</span>,-<span class="number">0x10</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,xxx</span><br></pre></td></tr></table></figure><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011023348.png"></p><p>QT特点：</p><p><img src="/2023/10/11/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E5%8E%9F%E7%90%86%E5%8D%B3%E5%AF%B9%E5%9D%91-UPX%E4%B8%BA%E4%BE%8B/QQ%E6%88%AA%E5%9B%BE20231011023957.png"></p><p>本篇文章是拿最简单的壳开刀的，但是大致套路就是这样的，所谓万变不离其宗</p><p>参考链接：</p><p><a href="https://www.52pojie.cn/thread-1640646-1-1.html">各种程序的OEP入口特征汇总整理!专为小白总结！ - 『脱壳破解区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://www.52pojie.cn/thread-234739-1-1.html">【初学者教程】破解基础知识之认识壳与程序的特征 - 『脱壳破解讨论求助区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p><p><a href="https://zhuanlan.zhihu.com/p/34263050#:~:text=%E8%84%B1%E5%A3%B3%E4%B8%AD%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E4%B8%80%E6%AD%A5%EF%BC%8C%E4%B8%8D%E8%AE%BA%E6%98%AF%E5%8E%8B%E7%BC%A9%E5%A3%B3%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AF%86%E5%A3%B3%EF%BC%8C%E5%9C%A8%E8%84%B1%E5%A3%B3%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%83%BD%E9%9C%80%E8%A6%81%E4%BF%AE%E5%A4%8DIAT%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%84%B1%E5%A3%B3%E6%97%B6%E4%BC%9A%E5%B0%86%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%82%A8,(dump)%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E4%BF%9D%E5%AD%98%E6%88%90%E6%96%87%E4%BB%B6%EF%BC%8C%E8%80%8CIAT%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E4%B8%80%E4%B8%AARVA%E6%95%B0%E7%BB%84%EF%BC%8C%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80%E6%95%B0%E7%BB%84%E3%80%82">使用x64dbg脱壳之开源壳upx - 知乎 (zhihu.com)</a></p><p>[<a href="https://bbs.kanxue.com/thread-226967.htm">原创]脱壳步骤，修复IAT的原因及修复IAT的完整步骤-加壳脱壳-看雪-安全社区|安全招聘|kanxue.com</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是壳&quot;&gt;&lt;a href=&quot;#什么是壳&quot; class=&quot;headerlink&quot; title=&quot;什么是壳&quot;&gt;&lt;/a&gt;什么是壳&lt;/h3&gt;&lt;p&gt;壳，分为&lt;strong&gt;压缩壳&lt;/strong&gt;，&lt;strong&gt;保护壳&lt;/strong&gt;，&lt;strong&gt;伪装壳&lt;/strong&gt;（对抗杀毒软件）&lt;/p&gt;
&lt;p&gt;这篇文章讲以下压缩壳，压缩壳可以有效减少程序的体积，同时由于压缩之后的代码比较难懂，所以也有一定的保护作用，最常见的就是UPX壳。压缩壳不同于一般的压缩（7zp、rar等），它不需要解压缩操作，程序可以直接运行，用到的是一种&lt;strong&gt;运行时解压缩&lt;/strong&gt;技术。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UPX" scheme="http://example.com/tags/UPX/"/>
    
    <category term="运行时压缩" scheme="http://example.com/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="壳" scheme="http://example.com/tags/%E5%A3%B3/"/>
    
  </entry>
  
</feed>
